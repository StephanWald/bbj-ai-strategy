---
phase: 29-ingestion-performance
plan: 03
type: execute
wave: 3
depends_on: ["29-02"]
files_modified:
  - rag-ingestion/src/bbj_rag/ingest_all.py
autonomous: false

must_haves:
  truths:
    - "bbj-ingest-all runs parallel by default"
    - "--sequential flag falls back to original sequential mode"
    - "--workers N overrides default worker count"
    - "--retry-failed processes only items from failure log"
    - "Exit code is non-zero if any batches failed"
  artifacts:
    - path: "rag-ingestion/src/bbj_rag/ingest_all.py"
      provides: "CLI with parallel ingestion integration"
      contains: "--sequential"
  key_links:
    - from: "rag-ingestion/src/bbj_rag/ingest_all.py"
      to: "ParallelIngestor"
      via: "import and instantiation"
      pattern: "from bbj_rag.parallel import ParallelIngestor"
---

<objective>
Integrate parallel ingestion into the bbj-ingest-all CLI with appropriate flags and verification.

Purpose: Make parallel ingestion the default behavior with fallback to sequential mode, enabling engineers to benefit from faster corpus rebuilds while maintaining a reliable fallback.

Output: Updated CLI with --sequential, --workers, --verbose, --retry-failed flags, plus verification that parallel mode delivers measurable speedup.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-ingestion-performance/29-CONTEXT.md
@.planning/phases/29-ingestion-performance/29-01-SUMMARY.md
@.planning/phases/29-ingestion-performance/29-02-SUMMARY.md
@rag-ingestion/src/bbj_rag/ingest_all.py
@rag-ingestion/src/bbj_rag/parallel.py
@rag-ingestion/src/bbj_rag/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update CLI flags for parallel mode</name>
  <files>rag-ingestion/src/bbj_rag/ingest_all.py</files>
  <action>
Update the bbj-ingest-all CLI to support parallel ingestion:

1. **Change --parallel flag to --sequential:**
   - Remove the existing --parallel flag (currently prints warning and falls back)
   - Add --sequential flag: "Run sources sequentially instead of parallel (default: parallel)"
   - Parallel is now the default behavior

2. **Add --workers flag:**
   ```python
   @click.option(
       "--workers",
       default=None,
       type=int,
       help="Number of parallel workers (default: 4, max: 8)",
   )
   ```
   - If not specified, use settings.ingest_workers (default 4)
   - Cap at settings.ingest_max_workers (default 8) with warning if exceeded

3. **Enhance --verbose flag:**
   - Already exists, but now passes to ParallelIngestor for per-worker output

4. **Add --retry-failed flag:**
   ```python
   @click.option(
       "--retry-failed",
       is_flag=True,
       help="Only process items from previous failure log",
   )
   ```
   - When set, load failure log and filter sources/chunks accordingly
   - If failure log doesn't exist, print message and exit 0

5. **Update function signature:**
   ```python
   def ingest_all(
       config: str,
       clean: bool,
       resume: bool,
       sequential: bool,  # Changed from parallel
       verbose: bool,
       source_names: tuple[str, ...],
       data_dir_override: str | None,
       workers: int | None,  # New
       retry_failed: bool,  # New
   ) -> None:
   ```
  </action>
  <verify>
Run: cd rag-ingestion && uv run bbj-ingest-all --help
Should show:
- --sequential flag (not --parallel)
- --workers N option
- --retry-failed flag
- --verbose flag
  </verify>
  <done>CLI has --sequential, --workers, --retry-failed flags. Parallel mode is the default.</done>
</task>

<task type="auto">
  <name>Task 2: Implement parallel ingestion flow</name>
  <files>rag-ingestion/src/bbj_rag/ingest_all.py</files>
  <action>
Integrate ParallelIngestor into the main ingestion loop:

1. **Worker count resolution:**
   ```python
   num_workers = workers or settings.ingest_workers
   if num_workers > settings.ingest_max_workers:
       click.echo(f"Warning: Capping workers at {settings.ingest_max_workers}")
       num_workers = settings.ingest_max_workers
   ```

2. **Parallel ingestion branch:**
   When not sequential mode:
   - Create ParallelIngestor instance
   - For each source, collect all chunks first (parse + chunk without embedding)
   - Call ingest_chunks() with the collected chunks
   - Handle IngestResult and update stats

3. **Sequential fallback:**
   When --sequential is passed:
   - Use existing run_pipeline() flow unchanged
   - Print "(sequential mode)" in output

4. **Failure handling:**
   - If result.batches_failed > 0, save failure log
   - Print hint: "Some batches failed. Re-run with --retry-failed"
   - Exit with code 1 for partial failure

5. **Summary table update:**
   - Add "Mode" column showing "parallel (4w)" or "sequential"
   - Show comparison hint if running parallel: "Compare with --sequential for baseline"

6. **Retry-failed flow:**
   When --retry-failed is set:
   - Load failure log
   - Filter to only process sources with failed chunks
   - Re-embed and store only the failed chunks
   - Clear successful items from failure log
  </action>
  <verify>
Run: cd rag-ingestion && uv run bbj-ingest-all --source pdf --sequential --clean
Should run in sequential mode and print "(sequential mode)" in output.

Run: cd rag-ingestion && uv run bbj-ingest-all --source pdf --clean --workers 2
Should run with 2 workers and print worker count in output.
  </verify>
  <done>Parallel ingestion works as default, --sequential falls back to original flow, --workers controls concurrency, --retry-failed processes failure log.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Parallel ingestion for bbj-ingest-all with:
- Parallel mode as default (4 workers)
- --sequential flag for fallback
- --workers N for custom worker count
- --retry-failed for failure recovery
- Persistent HTTP connections via httpx.AsyncClient
  </what-built>
  <how-to-verify>
Performance verification (compare parallel vs sequential):

1. Ensure Ollama is running: `ollama list` should show qwen3-embedding:0.6b

2. Run sequential baseline on a single source:
   ```bash
   cd rag-ingestion
   time uv run bbj-ingest-all --source pdf --clean --sequential
   ```
   Note the total time.

3. Run parallel mode on the same source:
   ```bash
   time uv run bbj-ingest-all --source pdf --clean --workers 4
   ```
   Note the total time.

4. Compare times:
   - Parallel should be measurably faster (targeting 1.5-2x)
   - If parallel is slower or same, there may be an issue with worker coordination

5. Test failure recovery (optional):
   - Kill Ollama mid-ingestion to trigger failures
   - Check that .ingestion-failures.json is created
   - Run --retry-failed to verify it processes only failed items

Expected outcomes:
- Parallel mode completes successfully
- Parallel is faster than sequential (at least 1.3x for meaningful corpus)
- Summary table shows mode and worker count
- Exit code 0 for full success, 1 for partial failure
  </how-to-verify>
  <resume-signal>Type "approved" if parallel shows speedup, or describe issues if not</resume-signal>
</task>

</tasks>

<verification>
1. bbj-ingest-all --help shows new flags (--sequential, --workers, --retry-failed)
2. Default mode is parallel (no flag needed)
3. --sequential uses original run_pipeline flow
4. --workers N sets worker count (capped at max)
5. Parallel mode is measurably faster than sequential
6. Failure log created when batches fail
7. --retry-failed processes only failed items
8. Exit code 1 for partial failures
9. All existing tests pass
</verification>

<success_criteria>
- Parallel is the default (--sequential to disable)
- --workers N controls concurrency (default 4, max 8)
- --retry-failed processes failure log
- Performance improvement measurable (targeting 1.5-2x)
- Backward compatible (--sequential produces same results)
- Phase 29 success criteria from roadmap met:
  1. Parallel mode measurably faster than sequential
  2. Multiple workers process without GPU saturation errors
  3. HTTP connections reused across batches
</success_criteria>

<output>
After completion, create `.planning/phases/29-ingestion-performance/29-03-SUMMARY.md`
</output>
