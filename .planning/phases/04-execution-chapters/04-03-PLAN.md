---
phase: 04-execution-chapters
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - docs/06-rag-database/index.md
autonomous: true

must_haves:
  truths:
    - "A reader understands the multi-generation document structure with generation metadata on every chunk"
    - "The chapter recommends pgvector as the pragmatic default for BBj's corpus size with clear rationale"
    - "Hybrid search (BM25 + dense embeddings + reranking) is presented as the recommended retrieval strategy"
    - "The MadCap Flare to RAG ingestion pipeline is described with enough specificity to guide implementation"
    - "A Current Status section states the source corpus is identified but the pipeline is not yet built"
  artifacts:
    - path: "docs/06-rag-database/index.md"
      provides: "Chapter 6: RAG Database Design"
      min_lines: 300
      contains: "TL;DR"
  key_links:
    - from: "docs/06-rag-database/index.md"
      to: "/docs/fine-tuning"
      via: "cross-reference link"
      pattern: "/docs/fine-tuning"
    - from: "docs/06-rag-database/index.md"
      to: "/docs/ide-integration"
      via: "cross-reference link"
      pattern: "/docs/ide-integration"
---

<objective>
Write Chapter 6: RAG Database Design -- covering the multi-generation document structure, MadCap Flare ingestion pipeline, chunking strategy, embedding approach, vector store selection (pgvector), and hybrid retrieval with generation-aware filtering.

Purpose: Chapter 6 is the technical core of the retrieval layer. Both the IDE extension and documentation chat depend on this pipeline. A developer reader should understand exactly how BBj documentation gets from MadCap Flare into retrievable, generation-tagged chunks.

Output: Complete Chapter 6 replacing the current placeholder (~14 lines) with a researched, execution-depth chapter (~300-400 lines) matching Chapter 3's depth.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-execution-chapters/04-CONTEXT.md
@.planning/phases/04-execution-chapters/04-RESEARCH.md

# Source material from the strategy paper (lines 610-748)
@bbj-llm-strategy.md

# Pattern reference
@docs/03-fine-tuning/index.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write Chapter 6 -- RAG Database Design</name>
  <files>docs/06-rag-database/index.md</files>
  <action>
Read the source material and research, then replace the placeholder content in docs/06-rag-database/index.md with a complete chapter.

**Source material to absorb before writing:**
1. bbj-llm-strategy.md lines 610-748 (Component 4: RAG Database Design)
2. .planning/phases/04-execution-chapters/04-RESEARCH.md -- Chapter 6 sections (MadCap Flare Content Format, Chunking Strategy, Vector Database Recommendation, Embedding Model Strategy, Hybrid Search Architecture)
3. .planning/phases/04-execution-chapters/04-CONTEXT.md -- Chapter 6 framing: comprehensive corpus scope, cover industry best practices then apply to BBj

**Required structure (follow this order):**

1. **Frontmatter** -- keep sidebar_position: 1, update description
2. **TL;DR block** (:::tip[TL;DR]) -- 2-3 sentences: generation-tagged documentation corpus, hybrid retrieval (semantic + keyword), pgvector as pragmatic default, shared pipeline powers both IDE and chat
3. **Opening paragraph** -- The retrieval layer is the bridge between raw documentation and AI-powered answers. Connect to Chapter 2 (shared infrastructure) and explain that both IDE context enrichment and chat responses depend on this pipeline.
4. **Source Corpus** -- What goes into the RAG database: MadCap Flare documentation (primary), BBj source code, API references, knowledge base articles. Brief description of each source type and its value. Mermaid diagram: RAG Pipeline Architecture from RESEARCH.md (graph LR with Source Corpus -> Ingestion Pipeline -> Vector Store).
5. **MadCap Flare Ingestion** -- Specific pipeline for the primary documentation source. Explain: Flare stores content as W3C XHTML topics, Clean XHTML export strips proprietary tags, no programmatic API (must export or parse files). Include the FlareDocument TypeScript interface from RESEARCH.md. Decision callout: Clean XHTML as the ingestion format.
6. **Multi-Generation Document Structure** -- The core design: every chunk carries generation metadata. Use the same generation labeling schema as Chapter 3's training data (all, character, vpro5, bbj-gui, dwc). Include JSON examples from the strategy paper (universal doc, modern API doc, legacy doc with supersedes relationship). Explain the document types table from the paper (language-reference, api-reference, concept, example, migration, best-practice, version-note).
7. **Chunking Strategy** -- Document-type-aware chunking from RESEARCH.md: API references (200-400 tokens), conceptual docs (400-600 tokens), code examples (keep intact), migration guides (400-600 tokens with headers). Explain contextual headers (prepend section hierarchy to every chunk). 10-15% overlap between chunks. Decision callout: why different chunk sizes for different content types.
8. **Embedding Strategy** -- Start with strong general embedding model (BGE-M3 or similar open-source). BBj documentation is mostly English text, so generic embeddings work well initially. Code-aware embeddings for snippets. Fine-tuning with 1K-5K samples is feasible for 7%+ improvement but defer until baseline is established.
9. **Vector Store Selection** -- Decision callout: pgvector as default. Rationale from RESEARCH.md: BBj corpus under 50K chunks, pgvector and dedicated DBs perform identically at this scale, avoids running separate service, SQL joins for metadata filtering. Present Qdrant/Weaviate as scaling alternatives. Include the "as of 2026" framing.
10. **Hybrid Retrieval Strategy** -- The recommended approach: (1) dense vector search via pgvector, (2) sparse keyword search via PostgreSQL full-text/BM25, (3) Reciprocal Rank Fusion (0.7 semantic / 0.3 keyword), (4) cross-encoder reranking on top-20 to select top-5, (5) generation filtering via metadata. Include the TypeScript retrieveDocumentation function from RESEARCH.md. Explain BBj-specific value: API names like BBjSysGui.addWindow() benefit from keyword matching while conceptual questions benefit from semantic search.
11. **Generation-Aware Retrieval** -- How generation metadata filters results: if the user's context is DWC, boost DWC and bbj-gui docs, include universal docs, deprioritize character-only docs. Include the computeGenerationScore function from the strategy paper (or a simplified version).
12. **Current Status** -- :::note[Where Things Stand -- January 2026] admonition. Defined: source corpus identified (MadCap Flare, source code, API refs, knowledge base). Not built: ingestion pipeline, vector store, embedding computation. Planned: pilot with subset of API reference docs first.
13. **Cross-references** -- Link to /docs/fine-tuning (training data uses same generation schema), /docs/ide-integration (consumer of retrieval API), /docs/documentation-chat (consumer of retrieval API), /docs/strategic-architecture (shared infrastructure), /docs/implementation-roadmap (timeline).

**Content patterns to follow:**
- :::tip[TL;DR] at top
- At least 2-3 :::info[Decision: ...] callouts (pgvector, Clean XHTML ingestion, chunking strategy)
- At least 1 Mermaid diagram (RAG pipeline architecture)
- JSON examples for document structure
- TypeScript code examples for retrieval logic
- Architecture-first framing: describe requirements, then reference tools
- No "Coming Soon" text

**What to AVOID:**
- Do NOT write a generic RAG tutorial -- every concept must be immediately applied to BBj's unique requirements (generation tagging, MadCap Flare, multi-generation retrieval)
- Do NOT skip the MadCap Flare specifics -- this is a critical differentiator
- Do NOT recommend tools without "as of [date]" framing
- Do NOT make the chapter shorter than 300 lines
- Do NOT use .mdx extension
  </action>
  <verify>
Run `npm run build` from the project root. Build must pass with zero errors. Then verify:
1. File exists and is >300 lines: `wc -l docs/06-rag-database/index.md`
2. Contains TL;DR: `grep -c "TL;DR" docs/06-rag-database/index.md`
3. Contains Decision callouts: `grep -c ":::info\[Decision:" docs/06-rag-database/index.md`
4. Contains Mermaid diagram: `grep -c "mermaid" docs/06-rag-database/index.md`
5. Contains Current Status: `grep -c "Current Status" docs/06-rag-database/index.md`
6. No "Coming Soon": `grep -c "Coming Soon" docs/06-rag-database/index.md` returns 0
7. Contains "pgvector": `grep -c "pgvector" docs/06-rag-database/index.md`
8. Contains generation metadata: `grep -c "generation" docs/06-rag-database/index.md`
9. Cross-references: `grep -c "/docs/" docs/06-rag-database/index.md`
  </verify>
  <done>
Chapter 6 is a complete, build-passing chapter of 300+ lines that covers the full RAG pipeline from MadCap Flare ingestion through generation-tagged chunking to hybrid retrieval. A developer reader understands how BBj documentation becomes retrievable context for both IDE and chat applications, with pgvector as the recommended vector store.
  </done>
</task>

</tasks>

<verification>
- `npm run build` passes with zero errors
- Chapter 6 replaces placeholder with substantive content (300+ lines)
- All content patterns: TL;DR, Decision callouts (2+), Mermaid diagram, Current Status
- Cross-references to at least 4 other chapters
- BBj-specific throughout (generation metadata, MadCap Flare, multi-generation retrieval)
- Not a generic RAG tutorial -- every section connects to BBj requirements
- pgvector recommended with clear rationale for BBj's corpus size
</verification>

<success_criteria>
A developer reader understands: (1) what sources feed the RAG database, (2) how MadCap Flare XHTML becomes chunks, (3) the generation metadata schema on every chunk, (4) why pgvector is the pragmatic choice, (5) how hybrid search works for BBj, and (6) that the pipeline is designed but not yet built. The chapter builds with zero errors.
</success_criteria>

<output>
After completion, create `.planning/phases/04-execution-chapters/04-03-SUMMARY.md`
</output>
