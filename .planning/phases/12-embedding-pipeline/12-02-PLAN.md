---
phase: 12-embedding-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - rag-ingestion/sql/schema.sql
  - rag-ingestion/src/bbj_rag/search.py
  - rag-ingestion/src/bbj_rag/cli.py
  - rag-ingestion/tests/validation_cases.yaml
  - rag-ingestion/tests/test_search_validation.py
autonomous: true

must_haves:
  truths:
    - "Dense vector similarity query returns relevant Flare chunks for a sample BBj query"
    - "BM25 keyword search returns relevant chunks for BBj-specific terms"
    - "Hybrid RRF search combines dense and BM25 results with rank fusion"
    - "Generation-filtered search restricts results to a specific BBj generation"
    - "Validation test cases are defined in YAML, not hardcoded in test code"
    - "Engineers can add new validation cases by editing YAML without writing code"
  artifacts:
    - path: "rag-ingestion/src/bbj_rag/search.py"
      provides: "Search query functions for dense vector, BM25 keyword, hybrid RRF, and generation-filtered retrieval"
      exports: ["dense_search", "bm25_search", "hybrid_search", "SearchResult"]
    - path: "rag-ingestion/tests/validation_cases.yaml"
      provides: "YAML data file with ~15 search validation test cases across 4 categories"
    - path: "rag-ingestion/tests/test_search_validation.py"
      provides: "Parametrized pytest suite loading cases from YAML"
  key_links:
    - from: "rag-ingestion/tests/test_search_validation.py"
      to: "rag-ingestion/tests/validation_cases.yaml"
      via: "yaml.safe_load loads test cases at parametrize time"
      pattern: "yaml.safe_load"
    - from: "rag-ingestion/tests/test_search_validation.py"
      to: "rag-ingestion/src/bbj_rag/search.py"
      via: "tests call dense_search, bm25_search, hybrid_search"
      pattern: "dense_search|bm25_search|hybrid_search"
    - from: "rag-ingestion/src/bbj_rag/search.py"
      to: "rag-ingestion/sql/schema.sql"
      via: "search functions use RRF SQL function and query chunks table"
      pattern: "rrf_score|embedding.*<=>|search_vector.*@@"
---

<objective>
Implement hybrid search functions (dense vector, BM25 keyword, RRF hybrid, generation-filtered) and a YAML-driven pytest validation suite that asserts search quality against embedded Flare documentation.

Purpose: This validates that the end-to-end pipeline produces searchable vectors -- proving success criteria 3, 4, and 5 from the phase goals. The YAML cases file is a key deliverable that engineers extend as they add sources in Phase 13+.

Output: search.py with 4 search functions, RRF SQL function in schema.sql, validation_cases.yaml with ~15 test cases, and test_search_validation.py with parametrized assertions. The `bbj-rag validate` CLI command wires to the validation suite.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-embedding-pipeline/12-RESEARCH.md
@.planning/phases/12-embedding-pipeline/12-01-SUMMARY.md

# Source files from Plan 12-01
@rag-ingestion/src/bbj_rag/embedder.py
@rag-ingestion/src/bbj_rag/db.py
@rag-ingestion/src/bbj_rag/cli.py
@rag-ingestion/sql/schema.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Search functions and RRF SQL function</name>
  <files>
    rag-ingestion/sql/schema.sql
    rag-ingestion/src/bbj_rag/search.py
  </files>
  <action>
**1a. Add RRF SQL function to schema.sql** -- Append to the end of schema.sql (after the existing index definitions):

```sql
-- Reciprocal Rank Fusion scoring function for hybrid search.
-- Combines dense vector and BM25 keyword rankings using RRF formula.
-- rrf_k=50 is the standard constant that prevents division by zero
-- and controls the influence of high-ranked results.
CREATE OR REPLACE FUNCTION rrf_score(rank int, rrf_k int DEFAULT 50)
RETURNS numeric AS $$
    SELECT COALESCE(1.0 / ($1 + $2), 0.0);
$$ LANGUAGE sql IMMUTABLE;
```

**1b. Create search.py** -- Search query module. Module: `rag-ingestion/src/bbj_rag/search.py`

Define a result dataclass:
```python
from dataclasses import dataclass

@dataclass(frozen=True, slots=True)
class SearchResult:
    id: int
    source_url: str
    title: str
    content: str
    doc_type: str
    generations: list[str]
    score: float
```

Implement four search functions, all taking a psycopg connection and returning `list[SearchResult]`:

**`dense_search(conn, query_embedding, limit=5, generation_filter=None)`**
- SQL: `SELECT id, source_url, title, content, doc_type, generations, 1 - (embedding <=> %s::vector) AS score FROM chunks`
- If `generation_filter` is not None, add `WHERE generations @> ARRAY[%s::text]` (uses GIN index)
- `ORDER BY embedding <=> %s::vector LIMIT %s`
- Return list of SearchResult

**`bm25_search(conn, query_text, limit=5, generation_filter=None)`**
- SQL: Use `plainto_tsquery('english', %s)` to create the query
- `SELECT id, source_url, title, content, doc_type, generations, ts_rank_cd(search_vector, query) AS score FROM chunks, plainto_tsquery('english', %s) query WHERE search_vector @@ query`
- If `generation_filter` is not None, add `AND generations @> ARRAY[%s::text]`
- `ORDER BY score DESC LIMIT %s`
- Return list of SearchResult

**`hybrid_search(conn, query_embedding, query_text, limit=5, generation_filter=None)`**
- Uses UNION ALL of dense and BM25 sub-queries with RRF scoring (from 12-RESEARCH.md Pattern: Hybrid Search SQL)
- Dense sub-query: top 20 by cosine distance, compute `rrf_score(rank)` using window function
- BM25 sub-query: top 20 by ts_rank_cd, compute `rrf_score(rank)` using window function
- Outer query: GROUP BY chunk fields, SUM(rrf_score) as combined score, ORDER BY score DESC, LIMIT
- If `generation_filter` is provided, add the `generations @> ARRAY[%s::text]` filter to BOTH sub-queries
- Return list of SearchResult

All functions should:
- Use parameterized queries (never f-string SQL)
- Handle empty result sets gracefully (return empty list)
- Use `conn.cursor()` context manager
- Cast the embedding parameter correctly for pgvector (`%s::vector`)

The generation_filter parameter enables success criteria validation for generation-filtered search (e.g., query filtered to bbj_gui generation).
  </action>
  <verify>
Run from rag-ingestion/:
```bash
uv run ruff check src/bbj_rag/search.py
uv run ruff format --check src/bbj_rag/search.py
uv run python -c "from bbj_rag.search import dense_search, bm25_search, hybrid_search, SearchResult; print('imports OK')"
uv run pytest -x
```
- Ruff passes
- Imports succeed
- Existing tests still pass
  </verify>
  <done>
- schema.sql includes rrf_score() SQL function
- search.py provides dense_search, bm25_search, hybrid_search functions
- All functions accept optional generation_filter parameter
- SearchResult frozen dataclass with all relevant fields
- Parameterized SQL (no string interpolation)
- Existing tests pass (no regressions)
  </done>
</task>

<task type="auto">
  <name>Task 2: YAML validation cases and parametrized test suite</name>
  <files>
    rag-ingestion/tests/validation_cases.yaml
    rag-ingestion/tests/test_search_validation.py
    rag-ingestion/src/bbj_rag/cli.py
  </files>
  <action>
**2a. Create validation_cases.yaml** -- YAML data file with ~15 search validation cases across 4 categories. File: `rag-ingestion/tests/validation_cases.yaml`

Structure:
```yaml
# Search validation cases for BBj RAG pipeline.
# Engineers: add new cases here -- no code changes needed.
# Each case has a query and expectations about the top-5 results.

dense_search:
  - query: "..."
    expect_in_top_5:
      - url_contains: "..."
    # Optional: expect_not_in_top_5, generation_filter

bm25_search:
  - query: "..."
    expect_in_top_5:
      - content_contains: "..."

filtered_search:
  - query: "..."
    filter_generation: "bbj_gui"
    expect_in_top_5:
      - generations_contains: "bbj_gui"

hybrid_search:
  - query: "..."
    expect_in_top_5:
      - title_contains: "..."
```

**Dense search cases (~5):**
1. Query: "How to add a button to a BBjWindow" -- expect url_contains "Window" or "addButton"
2. Query: "BBj string manipulation functions" -- expect doc_type "language-reference" or "api-reference"
3. Query: "Creating a child window in BBj" -- expect url_contains "Window" or title_contains "Window"
4. Query: "BBj event handling and callbacks" -- expect content_contains "callback" or "event"
5. Query: "DWC web component attributes" -- expect generations_contains "dwc"

**BM25 keyword cases (~4):**
1. Query: "BBjWindow addButton" -- expect url_contains "addButton"
2. Query: "PROCESS_EVENTS" -- expect content_contains "PROCESS_EVENTS"
3. Query: "setCallback" -- expect content_contains "setCallback" or "callback"
4. Query: "BBjGridExWidget" -- expect title_contains "Grid" or url_contains "Grid"

**Generation-filtered cases (~3):**
1. Query: "GUI window creation" with filter_generation "bbj_gui" -- expect generations_contains "bbj_gui"
2. Query: "web component styling" with filter_generation "dwc" -- expect generations_contains "dwc"
3. Query: "print statement syntax" with filter_generation "character" -- expect generations_contains "character" or "all"

**Hybrid search cases (~3):**
1. Query: "BBjWindow addButton method" -- expect url_contains "addButton" or "Window"
2. Query: "how to handle mouse click events in BBj" -- expect content_contains "click" or "mouse"
3. Query: "deprecated BBj functions" -- expect content_contains "deprecated" or deprecated field true

Total: ~15 cases. Design them so they will pass against real Flare documentation content. Use BBj-specific terms that appear in the actual Flare docs (based on knowledge of the BBj documentation structure: BBjObjects, methods, events, DWC components, language reference topics).

**2b. Create test_search_validation.py** -- Parametrized pytest suite. File: `rag-ingestion/tests/test_search_validation.py`

Implementation:
```python
import yaml
import pytest
from pathlib import Path
from bbj_rag.search import dense_search, bm25_search, hybrid_search
from bbj_rag.embedder import create_embedder
from bbj_rag.db import get_connection
from bbj_rag.config import Settings
```

Helper to load cases:
```python
CASES_FILE = Path(__file__).parent / "validation_cases.yaml"

def _load_cases(section: str) -> list[dict]:
    with CASES_FILE.open() as f:
        data = yaml.safe_load(f)
    return data.get(section, [])
```

Assertion helper:
```python
def _assert_result_matches(results, expectation):
    """Check that at least one result in the list matches the expectation dict."""
    for key, value in expectation.items():
        if key == "url_contains":
            assert any(value.lower() in r.source_url.lower() for r in results), \
                f"No result URL contains '{value}'. URLs: {[r.source_url for r in results]}"
        elif key == "title_contains":
            assert any(value.lower() in r.title.lower() for r in results), \
                f"No result title contains '{value}'. Titles: {[r.title for r in results]}"
        elif key == "content_contains":
            assert any(value.lower() in r.content.lower() for r in results), \
                f"No result content contains '{value}'"
        elif key == "doc_type":
            assert any(r.doc_type == value for r in results), \
                f"No result has doc_type '{value}'. Types: {[r.doc_type for r in results]}"
        elif key == "generations_contains":
            assert any(value in r.generations for r in results), \
                f"No result generations contain '{value}'"
```

Mark ALL tests in this file with a custom pytest marker `@pytest.mark.search_validation` so they can be run separately from unit tests (they require a database with embedded data):

```python
pytestmark = pytest.mark.search_validation
```

Add this marker to the pytest config in pyproject.toml:
```toml
[tool.pytest.ini_options]
markers = ["search_validation: requires database with embedded chunks"]
```

Fixtures (module-scoped for efficiency):
```python
@pytest.fixture(scope="module")
def settings():
    return Settings()

@pytest.fixture(scope="module")
def db_conn(settings):
    conn = get_connection(settings.database_url)
    yield conn
    conn.close()

@pytest.fixture(scope="module")
def embedder(settings):
    return create_embedder(settings)
```

Parametrized test functions:

```python
@pytest.mark.parametrize("case", _load_cases("dense_search"), ids=lambda c: c["query"][:50])
def test_dense_search(db_conn, embedder, case):
    query_vec = embedder.embed_batch([case["query"]])[0]
    generation_filter = case.get("filter_generation")
    results = dense_search(db_conn, query_vec, limit=5, generation_filter=generation_filter)
    assert len(results) > 0, f"No results for dense query: {case['query']}"
    for expectation in case.get("expect_in_top_5", []):
        _assert_result_matches(results, expectation)

@pytest.mark.parametrize("case", _load_cases("bm25_search"), ids=lambda c: c["query"][:50])
def test_bm25_search(db_conn, case):
    generation_filter = case.get("filter_generation")
    results = bm25_search(db_conn, case["query"], limit=5, generation_filter=generation_filter)
    assert len(results) > 0, f"No results for BM25 query: {case['query']}"
    for expectation in case.get("expect_in_top_5", []):
        _assert_result_matches(results, expectation)

@pytest.mark.parametrize("case", _load_cases("filtered_search"), ids=lambda c: c["query"][:50])
def test_filtered_search(db_conn, embedder, case):
    query_vec = embedder.embed_batch([case["query"]])[0]
    results = dense_search(db_conn, query_vec, limit=5, generation_filter=case["filter_generation"])
    assert len(results) > 0, f"No results for filtered query: {case['query']}"
    for expectation in case.get("expect_in_top_5", []):
        _assert_result_matches(results, expectation)

@pytest.mark.parametrize("case", _load_cases("hybrid_search"), ids=lambda c: c["query"][:50])
def test_hybrid_search(db_conn, embedder, case):
    query_vec = embedder.embed_batch([case["query"]])[0]
    generation_filter = case.get("filter_generation")
    results = hybrid_search(db_conn, query_vec, case["query"], limit=5, generation_filter=generation_filter)
    assert len(results) > 0, f"No results for hybrid query: {case['query']}"
    for expectation in case.get("expect_in_top_5", []):
        _assert_result_matches(results, expectation)
```

**2c. Update cli.py** -- Replace the placeholder `validate` command with one that invokes the validation suite:

```python
@cli.command()
@click.option('--verbose', '-v', 'val_verbose', is_flag=True, help='Show detailed results')
def validate(val_verbose: bool) -> None:
    """Run search validation assertions against embedded data."""
    import subprocess
    import sys
    args = [sys.executable, '-m', 'pytest', 'tests/test_search_validation.py', '-v', '-m', 'search_validation']
    if val_verbose:
        args.append('-s')
    result = subprocess.run(args, cwd=str(Path(__file__).resolve().parents[2]))
    sys.exit(result.returncode)
```

This delegates to pytest so the validation cases are run as proper assertions with full pytest reporting. The `-m search_validation` marker ensures only search validation tests run, not the full suite.

Also update the default `pytest` invocation in pyproject.toml to EXCLUDE search_validation by default (so `uv run pytest` doesn't try to connect to a database):
```toml
addopts = ["-ra", "-q", "-m", "not search_validation"]
```

This means:
- `uv run pytest` runs all unit tests (fast, no DB needed)
- `uv run pytest -m search_validation` runs only validation tests (requires DB + embedded data)
- `uv run bbj-rag validate` is a convenience wrapper for the above
  </action>
  <verify>
Run from rag-ingestion/:
```bash
uv run ruff check src/bbj_rag/search.py tests/test_search_validation.py
uv run ruff format --check src/bbj_rag/search.py tests/test_search_validation.py
uv run python -c "import yaml; data = yaml.safe_load(open('tests/validation_cases.yaml')); print(f'Loaded {sum(len(v) for v in data.values())} cases across {len(data)} categories')"
uv run pytest -x  # Unit tests only (excludes search_validation)
uv run bbj-rag validate --help
```
- Ruff passes on all new files
- YAML file loads successfully with ~15 cases across 4 categories
- Unit tests pass (search_validation tests excluded by default)
- `bbj-rag validate --help` shows the command description and --verbose flag

Note: The actual search validation tests (`uv run pytest -m search_validation`) require a running PostgreSQL database with embedded Flare data. They will be run after `bbj-rag ingest --source flare` populates the database. This is by design -- validation tests are integration tests that prove the pipeline works end-to-end.
  </verify>
  <done>
- search.py provides dense_search, bm25_search, hybrid_search, and SearchResult
- schema.sql includes rrf_score() function for hybrid search
- validation_cases.yaml has ~15 cases across 4 categories (dense, bm25, filtered, hybrid)
- test_search_validation.py has parametrized tests loading from YAML
- search_validation pytest marker separates integration tests from unit tests
- `bbj-rag validate` CLI command invokes the validation suite
- Default `pytest` excludes search_validation tests (no DB required for unit tests)
- Engineers can add validation cases by editing YAML -- no code changes needed
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. `uv run ruff check src/ tests/` passes with no errors
2. `uv run pytest -x` passes all unit tests (search_validation excluded)
3. `uv run python -c "from bbj_rag.search import dense_search, bm25_search, hybrid_search"` succeeds
4. `uv run python -c "import yaml; yaml.safe_load(open('tests/validation_cases.yaml'))"` loads ~15 cases
5. `uv run bbj-rag validate --help` shows command description
6. sql/schema.sql includes rrf_score() function definition
7. pyproject.toml has search_validation marker and exclusion in default addopts

The full validation cycle (which requires a live database):
1. Start PostgreSQL with pgvector extension
2. Apply schema: `psql -f sql/schema.sql`
3. Run pipeline: `bbj-rag ingest --source flare`
4. Run validation: `bbj-rag validate` (or `pytest -m search_validation`)
5. All 15 validation cases pass
</verification>

<success_criteria>
- Dense vector similarity query returns relevant Flare chunks for sample BBj queries
- BM25 keyword search returns relevant chunks for BBj-specific terms (e.g., "BBjWindow addButton")
- Hybrid RRF search combines dense and BM25 results effectively
- Generation-filtered search restricts results to specified BBj generation
- Validation cases defined in YAML file, loadable and extensible without code changes
- Search validation tests are separated from unit tests via pytest marker
- CLI `validate` command runs the validation suite
</success_criteria>

<output>
After completion, create `.planning/phases/12-embedding-pipeline/12-02-SUMMARY.md`
</output>
