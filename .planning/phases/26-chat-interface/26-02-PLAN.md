---
phase: 26-chat-interface
plan: 02
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - rag-ingestion/src/bbj_rag/templates/chat.html
  - rag-ingestion/src/bbj_rag/static/chat.css
  - rag-ingestion/src/bbj_rag/static/chat.js
  - rag-ingestion/src/bbj_rag/api/chat.py
  - rag-ingestion/src/bbj_rag/app.py
autonomous: true

must_haves:
  truths:
    - "GET /chat serves an HTML page with a chat interface — input bar at bottom, conversation area above"
    - "Typing a question and pressing Enter/Send streams a response incrementally with visible text appearing token-by-token"
    - "Code blocks in responses have BBj syntax highlighting and a copy button"
    - "Source citations appear as clickable links that open in new tabs with source type labels"
    - "A pulsing dot indicator shows during streaming and disappears when complete"
    - "Stop button halts streaming mid-response; Clear button resets conversation"
    - "Input is disabled during streaming and re-enabled after completion or stop"
    - "Low confidence responses show a 'Based on limited sources' indicator"
    - "Empty state shows suggested example questions"
  artifacts:
    - path: "rag-ingestion/src/bbj_rag/templates/chat.html"
      provides: "Jinja2 template with full chat page layout, CDN imports for marked.js and Prism.js"
      contains: "marked.parse"
    - path: "rag-ingestion/src/bbj_rag/static/chat.css"
      provides: "Chat-specific styles matching documentation companion aesthetic"
      contains: "position: fixed"
    - path: "rag-ingestion/src/bbj_rag/static/chat.js"
      provides: "Vanilla JS: SSE consumer via fetch+ReadableStream, markdown rendering, stop/clear, copy buttons"
      contains: "ReadableStream"
  key_links:
    - from: "rag-ingestion/src/bbj_rag/static/chat.js"
      to: "/chat/stream"
      via: "fetch() POST with messages JSON body"
      pattern: "fetch.*chat/stream"
    - from: "rag-ingestion/src/bbj_rag/static/chat.js"
      to: "marked.parse"
      via: "Incremental markdown rendering of accumulated text"
      pattern: "marked\\.parse"
    - from: "rag-ingestion/src/bbj_rag/api/chat.py"
      to: "rag-ingestion/src/bbj_rag/templates/chat.html"
      via: "Jinja2Templates.TemplateResponse"
      pattern: "TemplateResponse.*chat\\.html"
    - from: "rag-ingestion/src/bbj_rag/app.py"
      to: "rag-ingestion/src/bbj_rag/static/"
      via: "StaticFiles mount at /static"
      pattern: "mount.*static"
---

<objective>
Build the complete chat frontend: Jinja2 HTML template, CSS styling, and vanilla JavaScript client that consumes the SSE streaming endpoint from Plan 01. The page renders at GET /chat with a documentation-companion aesthetic, bottom-fixed input, streaming markdown with BBj syntax highlighting, source citations, stop/clear controls, and copy buttons on code blocks.

Purpose: This is the user-facing half of the chat feature. Engineers will interact with this page to ask BBj questions. The design must feel like a natural extension of the documentation site, not a bolted-on chatbot.

Output: A fully functional chat page at /chat that streams Claude responses with proper markdown rendering, BBj code highlighting, and source citations.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/26-chat-interface/26-RESEARCH.md
@.planning/phases/26-chat-interface/26-CONTEXT.md
@.planning/phases/26-chat-interface/26-01-SUMMARY.md
@rag-ingestion/src/bbj_rag/api/chat.py
@rag-ingestion/src/bbj_rag/app.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create chat HTML template and CSS styles</name>
  <files>
    rag-ingestion/src/bbj_rag/templates/chat.html
    rag-ingestion/src/bbj_rag/static/chat.css
  </files>
  <action>
    **templates/chat.html — Full-page Jinja2 template:**

    Structure:
    - `<!DOCTYPE html>` with viewport meta, title "BBj Documentation Chat"
    - CDN imports in `<head>`:
      - Prism CSS theme: `https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism.min.css` (light theme, closest to docs site)
      - `chat.css` via `/static/chat.css`
    - `<body>` with layout:
      1. **Header bar** — "BBj Documentation Chat" title with a subtle "Powered by Claude" note and a "New Chat" button (top-right). Use the project's brand blue (#2563eb) for the header background. Include a small logo/icon area (can be text-based).
      2. **Conversation area** (`#conversation`) — scrollable div that fills the space between header and input bar. Contains the message history. Initially shows an empty state.
      3. **Empty state** (`#empty-state`, shown when no messages) — centered in conversation area:
         - Brief intro text: "Ask me anything about BBj programming"
         - 3-4 suggested questions as clickable chips/buttons:
           - "How do I create a BBj window with DWC?"
           - "What is the difference between BBj GUI and DWC?"
           - "How do I read a file in BBj?"
           - "Explain BBj string templates"
         - Clicking a suggestion fills the input and submits
      4. **Input bar** (`#input-bar`) — fixed to bottom of viewport:
         - Text input (or textarea for multi-line, but single-line is fine for v1) with placeholder "Ask a BBj question..."
         - Send button (right side, blue #2563eb)
         - Stop button (red, hidden by default, shown during streaming)
         - Enter key submits, Shift+Enter for newline if using textarea
    - Script imports at bottom of body:
      - Prism core: `https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-core.min.js`
      - Prism autoloader: `https://cdn.jsdelivr.net/npm/prismjs@1/plugins/autoloader/prism-autoloader.min.js` (handles BBj grammar loading on demand)
      - marked.js: `https://cdn.jsdelivr.net/npm/marked/lib/marked.esm.js` (ES module)
      - `/static/chat.js` as ES module (`type="module"`)

    **static/chat.css — Documentation companion styling:**

    Design principles: Clean, professional, matches Docusaurus docs site feel. Blue (#2563eb) primary color. White background. Subtle borders and shadows. Readable font sizes.

    Key styles:
    - `*` — box-sizing: border-box, margin/padding reset
    - `body` — font-family: system-ui, -apple-system, sans-serif; height: 100vh; display: flex; flex-direction: column; background: #f8fafc
    - `.header` — background: #2563eb; color: white; padding: 12px 20px; display: flex; justify-content: space-between; align-items: center; box-shadow
    - `.header h1` — font-size: 1.1rem; font-weight: 600
    - `.new-chat-btn` — background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 6px 14px; border-radius: 6px; cursor: pointer
    - `#conversation` — flex: 1; overflow-y: auto; padding: 20px; max-width: 800px; width: 100%; margin: 0 auto
    - `.message` — margin-bottom: 20px; line-height: 1.6
    - `.message.user` — background: #eff6ff; border-radius: 12px; padding: 12px 16px; margin-left: 40px (right-aligned feel)
    - `.message.assistant` — padding: 4px 0
    - `.message.assistant pre` — background: #1e1e1e; color: #d4d4d4; border-radius: 8px; padding: 16px; overflow-x: auto; position: relative; margin: 12px 0
    - `.message.assistant code` — font-family: 'SF Mono', 'Fira Code', monospace; font-size: 0.9em
    - `.copy-btn` — position: absolute; top: 8px; right: 8px; background: #374151; color: #d4d4d4; border: none; padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 0.75rem
    - `.copy-btn:hover` — background: #4b5563
    - `.sources-list` — margin-top: 8px; padding: 8px 12px; background: #f0f9ff; border-left: 3px solid #2563eb; border-radius: 0 6px 6px 0; font-size: 0.85rem
    - `.source-link` — color: #2563eb; text-decoration: none
    - `.source-type-badge` — display: inline-block; background: #e0e7ff; color: #3730a3; padding: 1px 6px; border-radius: 3px; font-size: 0.75rem; margin-left: 4px
    - `.streaming-indicator` — display: inline-block; width: 8px; height: 8px; background: #2563eb; border-radius: 50%; animation: pulse 1.5s infinite
    - `@keyframes pulse` — 0%,100% opacity:1; 50% opacity:0.3
    - `.low-confidence` — background: #fef3c7; border-left: 3px solid #f59e0b; padding: 8px 12px; border-radius: 0 6px 6px 0; font-size: 0.85rem; margin-bottom: 8px
    - `#empty-state` — text-align: center; padding: 60px 20px; color: #6b7280
    - `.suggestion-chip` — display: inline-block; background: white; border: 1px solid #d1d5db; padding: 8px 16px; border-radius: 20px; margin: 4px; cursor: pointer; color: #374151; transition: all 0.2s
    - `.suggestion-chip:hover` — border-color: #2563eb; color: #2563eb; background: #eff6ff
    - `#input-bar` — position: sticky; bottom: 0; background: white; border-top: 1px solid #e5e7eb; padding: 12px 20px; display: flex; gap: 8px; max-width: 800px; width: 100%; margin: 0 auto (centered input to match conversation width)
    - `#input-bar input` or textarea — flex: 1; padding: 10px 14px; border: 1px solid #d1d5db; border-radius: 8px; font-size: 1rem; outline: none
    - `#input-bar input:focus` — border-color: #2563eb; box-shadow: 0 0 0 2px rgba(37,99,235,0.2)
    - `.send-btn` — background: #2563eb; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: 500
    - `.send-btn:disabled` — opacity: 0.5; cursor: not-allowed
    - `.stop-btn` — background: #dc2626; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; display: none (hidden by default)
    - Wrapper for input area to center it: `.input-wrapper` — max-width: 840px (800 + padding); width: 100%; margin: 0 auto; padding: 12px 20px; background: white; border-top: 1px solid #e5e7eb

    Responsive: On small screens (< 640px), reduce padding, full-width messages (no margin-left on user messages).
  </action>
  <verify>
    - File exists: `ls rag-ingestion/src/bbj_rag/templates/chat.html` succeeds
    - File exists: `ls rag-ingestion/src/bbj_rag/static/chat.css` succeeds
    - Template references chat.js: `grep 'chat.js' rag-ingestion/src/bbj_rag/templates/chat.html` finds a match
    - Template references chat.css: `grep 'chat.css' rag-ingestion/src/bbj_rag/templates/chat.html` finds a match
    - Template references marked: `grep 'marked' rag-ingestion/src/bbj_rag/templates/chat.html` finds a match
    - Template references prism: `grep -i 'prism' rag-ingestion/src/bbj_rag/templates/chat.html` finds a match
    - CSS has brand color: `grep '2563eb' rag-ingestion/src/bbj_rag/static/chat.css` finds matches
    - CSS has position sticky or fixed for input: `grep -E 'position.*sticky|position.*fixed' rag-ingestion/src/bbj_rag/static/chat.css` finds a match
  </verify>
  <done>chat.html template exists with full page layout (header, conversation area, empty state with suggestions, bottom input bar). chat.css provides documentation-companion styling with brand blue, dark code blocks, source citation styles, streaming indicator animation, and responsive layout.</done>
</task>

<task type="auto">
  <name>Task 2: Create JavaScript SSE client and wire template serving</name>
  <files>
    rag-ingestion/src/bbj_rag/static/chat.js
    rag-ingestion/src/bbj_rag/api/chat.py
    rag-ingestion/src/bbj_rag/app.py
  </files>
  <action>
    **static/chat.js — Vanilla JS ES module, the complete chat client:**

    Import marked at top: `import { marked } from 'https://cdn.jsdelivr.net/npm/marked/lib/marked.esm.js';`

    Configure marked: `marked.setOptions({ breaks: true, gfm: true });`

    **State management:**
    - `let messages = [];` — conversation history (array of {role, content})
    - `let currentAbort = null;` — AbortController for stop button
    - `let isStreaming = false;` — UI state flag

    **DOM references (cached on DOMContentLoaded):**
    - `conversationEl`, `emptyStateEl`, `inputEl`, `sendBtn`, `stopBtn`, `newChatBtn`

    **Core function: `sendMessage(text)`:**
    1. If `isStreaming` or `text.trim() === ''`, return early.
    2. Hide empty state, show conversation.
    3. Push `{role: "user", content: text}` to `messages`.
    4. Append user message bubble to DOM: create div.message.user, set textContent.
    5. Clear input, disable input + send button, show stop button. Set `isStreaming = true`.
    6. Create assistant message bubble (div.message.assistant) with streaming indicator dot.
    7. Create `currentAbort = new AbortController()`.
    8. Call `streamResponse(messages, assistantBubble, currentAbort)`.
    9. Scroll conversation to bottom.

    **Core function: `async streamResponse(messagesArray, responseEl, abortCtrl)`:**
    1. `const response = await fetch('/chat/stream', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({messages: messagesArray}), signal: abortCtrl.signal });`
    2. If `!response.ok`, throw error with status.
    3. Set up ReadableStream reader: `const reader = response.body.getReader(); const decoder = new TextDecoder();`
    4. State: `let buffer = ''; let accumulated = ''; let currentEvent = 'message'; let renderPending = false; let sources = null; let lowConfidence = false;`
    5. `scheduleRender()` function using `requestAnimationFrame`:
       - If `renderPending` return.
       - Set `renderPending = true`.
       - In rAF callback: call `renderMarkdown(accumulated, responseEl)`, set `renderPending = false`.
    6. Read loop: `while (true) { const {done, value} = await reader.read(); if (done) break; ... }`
       - Decode chunk, append to buffer.
       - Split buffer on `\n`, keep last (potentially incomplete) line.
       - Parse each line:
         - `event: X` -> set currentEvent = X.trim()
         - `data: X` -> parse JSON payload, call handleEvent(currentEvent, data).
         - Empty line -> reset currentEvent to 'message'.
    7. `handleEvent(event, data)`:
       - `'sources'`: Store sources array. Check if any entry has `low_confidence: true` -> set lowConfidence flag. If lowConfidence, prepend a `.low-confidence` div to the response area.
       - `'delta'`: `accumulated += data.text; scheduleRender();`
       - `'done'`: Final render. Remove streaming indicator. Push `{role: "assistant", content: accumulated}` to messages. Display sources below the response. Add copy buttons to code blocks. Re-enable input.
       - `'error'`: Show error message in response area. Re-enable input.
    8. Catch block: If AbortError, just finalize (partial response is fine). Otherwise show error.
    9. Finally block: `isStreaming = false; currentAbort = null;` hide stop button, enable input + send button.

    **`renderMarkdown(text, element)` function:**
    - Handle unclosed code fences: count occurrences of ` ``` ` — if odd, append a closing fence to a temporary copy for rendering.
    - `element.innerHTML = marked.parse(renderText);`
    - Re-highlight code blocks: `element.querySelectorAll('pre code').forEach(block => Prism.highlightElement(block));`
    - Scroll conversation to bottom.

    **`addCopyButtons(element)` function:**
    - For each `pre` in element, if no `.copy-btn` child exists:
      - Create button with class `copy-btn`, text "Copy".
      - On click: `navigator.clipboard.writeText(pre.querySelector('code').textContent)`, then change text to "Copied!" for 2 seconds.
      - Append to pre.

    **`displaySources(sources, containerEl)` function:**
    - Create `.sources-list` div.
    - For each source: create a link element (`<a>` with class `source-link`, href=source.url, target=`_blank`), and a `.source-type-badge` span with the source_type text.
    - Append to container below the response text.

    **Event listeners (DOMContentLoaded):**
    - Send button click -> `sendMessage(inputEl.value)`
    - Input keydown Enter (without Shift) -> `sendMessage(inputEl.value)`
    - Stop button click -> `if (currentAbort) currentAbort.abort();`
    - New Chat button click -> clear messages array, clear conversation innerHTML, show empty state, re-enable input.
    - Suggestion chip clicks -> `sendMessage(chip.dataset.query)`

    **api/chat.py — Update GET /chat to serve template:**
    - Replace the placeholder HTMLResponse with proper Jinja2 template rendering.
    - Import: `from fastapi.templating import Jinja2Templates`, `from pathlib import Path`
    - Set up templates directory: `templates = Jinja2Templates(directory=str(Path(__file__).resolve().parent.parent / "templates"))`
    - GET /chat handler: `return templates.TemplateResponse("chat.html", {"request": request})`

    **app.py — Mount static files:**
    - Import: `from fastapi.staticfiles import StaticFiles`, `from pathlib import Path`
    - After router includes, mount static: `app.mount("/static", StaticFiles(directory=str(Path(__file__).resolve().parent / "static")), name="static")`
    - IMPORTANT: The StaticFiles mount must come AFTER all router includes (since it's a catch-all mount pattern).
  </action>
  <verify>
    - `ls rag-ingestion/src/bbj_rag/static/chat.js` succeeds
    - `grep 'fetch.*chat/stream' rag-ingestion/src/bbj_rag/static/chat.js` finds the SSE fetch call
    - `grep 'marked.parse' rag-ingestion/src/bbj_rag/static/chat.js` finds the markdown rendering call
    - `grep 'AbortController' rag-ingestion/src/bbj_rag/static/chat.js` finds the stop button implementation
    - `grep 'ReadableStream\|getReader' rag-ingestion/src/bbj_rag/static/chat.js` finds the stream reader
    - `grep 'TemplateResponse' rag-ingestion/src/bbj_rag/api/chat.py` confirms template rendering
    - `grep 'StaticFiles' rag-ingestion/src/bbj_rag/app.py` confirms static files mount
    - `cd rag-ingestion && uv run python -c "from bbj_rag.app import app; print([r.path for r in app.routes if hasattr(r, 'path')])"` includes /chat and /static
    - `cd rag-ingestion && uv run pytest tests/ -x -q` passes (no regressions)
  </verify>
  <done>chat.js is a complete SSE client using fetch+ReadableStream with incremental markdown rendering via marked.js, Prism.js syntax highlighting, copy buttons, stop/clear controls, suggestion chips, low-confidence indicator, and requestAnimationFrame debouncing. api/chat.py serves the template via Jinja2. app.py mounts /static for CSS/JS assets. All existing tests pass.</done>
</task>

</tasks>

<verification>
1. `ls rag-ingestion/src/bbj_rag/templates/chat.html rag-ingestion/src/bbj_rag/static/chat.css rag-ingestion/src/bbj_rag/static/chat.js` — all three files exist
2. `grep 'TemplateResponse' rag-ingestion/src/bbj_rag/api/chat.py` — template rendering is wired
3. `grep 'StaticFiles' rag-ingestion/src/bbj_rag/app.py` — static files mounted
4. `grep 'fetch.*chat/stream' rag-ingestion/src/bbj_rag/static/chat.js` — JS calls the SSE endpoint
5. `grep 'marked.parse' rag-ingestion/src/bbj_rag/static/chat.js` — markdown rendering present
6. `grep 'Prism.highlightElement' rag-ingestion/src/bbj_rag/static/chat.js` — syntax highlighting present
7. `grep 'AbortController' rag-ingestion/src/bbj_rag/static/chat.js` — stop button implemented
8. `uv run pytest tests/ -x -q` — no regressions
</verification>

<success_criteria>
- GET /chat serves a styled HTML page with documentation-companion aesthetic
- The page has a bottom-fixed input bar, scrollable conversation area, and empty state with suggested questions
- chat.js streams responses from POST /chat/stream using fetch + ReadableStream
- Markdown is rendered incrementally with requestAnimationFrame debouncing
- Code blocks get Prism.js syntax highlighting (including BBj) and copy buttons
- Stop button aborts streaming; Clear/New Chat resets conversation
- Input is disabled during streaming
- Low-confidence indicator shows when RAG context is thin
- Source citations display as clickable links with source type badges
- No existing tests broken
</success_criteria>

<output>
After completion, create `.planning/phases/26-chat-interface/26-02-SUMMARY.md`
</output>
