---
phase: 30-bbjapi-javadoc-ingestion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rag-ingestion/src/bbj_rag/parsers/javadoc.py
autonomous: true

must_haves:
  truths:
    - "Parser yields one Document per class from JavaDoc JSON files"
    - "Each Document contains class name, description, and full method listing"
    - "HTML documentation strings are converted to Markdown"
    - "display_url is extracted from [Docs](https://...) links"
  artifacts:
    - path: "rag-ingestion/src/bbj_rag/parsers/javadoc.py"
      provides: "JavaDocParser class implementing DocumentParser protocol"
      exports: ["JavaDocParser"]
      min_lines: 100
  key_links:
    - from: "rag-ingestion/src/bbj_rag/parsers/javadoc.py"
      to: "bbj_rag.models.Document"
      via: "yield Document(...)"
      pattern: "yield Document\\("
---

<objective>
Create the JavaDoc JSON parser that reads BBj API documentation from structured JSON files and yields Document objects suitable for RAG ingestion.

Purpose: This parser enables the RAG system to answer questions about BBj API methods and classes by providing structured API reference data as "class reference cards."

Output: A new parser module `javadoc.py` that implements the DocumentParser protocol and produces one Document per class.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/30-bbjapi-javadoc-ingestion/30-CONTEXT.md
@.planning/phases/30-bbjapi-javadoc-ingestion/30-RESEARCH.md

# Existing parser patterns
@rag-ingestion/src/bbj_rag/parsers/__init__.py
@rag-ingestion/src/bbj_rag/parsers/bbj_source.py
@rag-ingestion/src/bbj_rag/models.py

# HTML-to-Markdown utility
@rag-ingestion/src/bbj_rag/parsers/web_crawl.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JavaDoc JSON parser</name>
  <files>rag-ingestion/src/bbj_rag/parsers/javadoc.py</files>
  <action>
Create `javadoc.py` implementing the DocumentParser protocol. The parser should:

1. **Constructor**: Accept `javadoc_dir: Path` parameter (directory containing *.json files)

2. **parse() generator**: Iterate through all JSON files in the directory:
   - Load each JSON file with `json.load()`
   - Extract package name from the `name` field
   - For each class in `classes` array, yield one Document

3. **Class to Document conversion**:
   - `source_url`: `bbj_api://{class_name}` (e.g., `bbj_api://BBjWindow`)
   - `title`: Class name
   - `doc_type`: `"api_reference"`
   - `generations`: `["bbj_gui", "dwc"]` (BBjAPI applies to both)
   - `context_header`: `"BBj API Reference > {class_name}"`
   - `display_url`: Extract from class's `docu` field using regex `\[Docs\]\((https://documentation\.basis\.cloud/[^)]+)\)`
   - `metadata`: `{"source_type": "bbj_api", "package": package_name}`
   - `deprecated`: `False`

4. **Content formatting** (class reference card):
   ```markdown
   # {ClassName}

   {class_description_as_markdown}

   **Package:** {package_name}
   **Documentation:** {display_url}

   ## Methods

   - `{method1_name}({param1}, {param2}, ...)` - {method1_description}
   - `{method2_name}()` - {method2_description}
   ...
   ```

5. **HTML to Markdown conversion**:
   - Use BeautifulSoup to parse HTML fragments in `docu` fields
   - Extract text content, preserving structure
   - Normalize line endings: `text.replace('\r\n', '\n').replace('\r', '\n')`
   - Handle HTML entities (BeautifulSoup does this automatically)

6. **Method signature formatting**:
   - Format: `methodName(param1, param2, ...)`
   - Extract param names from `params` array's `name` field
   - List each overloaded method separately (don't group)

7. **Handle edge cases**:
   - Classes with empty `docu`: Use class name only, no description
   - Methods with empty `docu`: List signature without description
   - Missing `[Docs]` link: Use empty string for display_url

Reference the RESEARCH.md for JSON structure examples and pitfall avoidance.
  </action>
  <verify>
Run unit test or manual verification:
```bash
cd rag-ingestion
python -c "
from pathlib import Path
from bbj_rag.parsers.javadoc import JavaDocParser

# Test with actual JavaDoc files
parser = JavaDocParser(Path('/Users/beff/bbx/documentation/javadoc'))
docs = list(parser.parse())
print(f'Parsed {len(docs)} classes')

# Check a known class
bbj_window = next((d for d in docs if d.title == 'BBjWindow'), None)
if bbj_window:
    print(f'BBjWindow source_url: {bbj_window.source_url}')
    print(f'BBjWindow display_url: {bbj_window.display_url}')
    print(f'BBjWindow content preview: {bbj_window.content[:500]}...')
    print(f'Has Methods section: {\"## Methods\" in bbj_window.content}')
else:
    print('ERROR: BBjWindow not found')
"
```
  </verify>
  <done>
Parser yields ~359 Document objects (one per class). Each Document has:
- `source_url` in `bbj_api://{class}` format
- `display_url` extracted from [Docs] links
- Content formatted as class reference card with ## Methods section
- Markdown-formatted description (no HTML tags)
  </done>
</task>

</tasks>

<verification>
1. Parser implements DocumentParser protocol (has `parse()` method yielding Document)
2. All 7 JSON files are processed without errors
3. Output Documents pass Pydantic validation (non-empty content, generations)
4. HTML entities are decoded (no `&#160;` or `&nbsp;` in output)
5. Method signatures include parameter names
</verification>

<success_criteria>
- `JavaDocParser` class exists in `javadoc.py`
- Parsing `/Users/beff/bbx/documentation/javadoc/` yields ~359 Documents
- BBjWindow Document contains "addButton" in its methods list
- display_url values start with `https://documentation.basis.cloud/`
</success_criteria>

<output>
After completion, create `.planning/phases/30-bbjapi-javadoc-ingestion/30-01-SUMMARY.md`
</output>
