---
phase: 23-mcp-server
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rag-ingestion/pyproject.toml
  - rag-ingestion/src/bbj_rag/mcp_server.py
autonomous: false

user_setup:
  - service: claude-desktop
    why: "MCP server requires Claude Desktop restart to pick up new config"
    dashboard_config:
      - task: "Restart Claude Desktop after config is written"
        location: "Quit and relaunch the Claude Desktop application"

must_haves:
  truths:
    - "search_bbj_knowledge tool appears in Claude Desktop's tool list"
    - "Invoking the tool with query 'BBjGrid' returns formatted text blocks with documentation content"
    - "The tool accepts an optional generation parameter that filters results by BBj product generation"
    - "MCP server runs on the host via stdio transport (not inside Docker)"
    - "MCP server returns a clear error message when the REST API is not running"
  artifacts:
    - path: "rag-ingestion/src/bbj_rag/mcp_server.py"
      provides: "MCP server module with search_bbj_knowledge tool"
      min_lines: 60
      contains: "FastMCP"
    - path: "rag-ingestion/pyproject.toml"
      provides: "mcp dependency and bbj-mcp script entry"
      contains: "mcp"
  key_links:
    - from: "rag-ingestion/src/bbj_rag/mcp_server.py"
      to: "http://localhost:10800/search"
      via: "httpx.AsyncClient POST request"
      pattern: "httpx\\.AsyncClient.*POST.*search"
    - from: "~/Library/Application Support/Claude/claude_desktop_config.json"
      to: "rag-ingestion/src/bbj_rag/mcp_server.py"
      via: "uv run python -m bbj_rag.mcp_server"
      pattern: "bbj_rag\\.mcp_server"
    - from: "rag-ingestion/src/bbj_rag/mcp_server.py"
      to: "stdout (JSON-RPC)"
      via: "mcp.run(transport='stdio')"
      pattern: "transport.*stdio"
---

<objective>
Implement the `search_bbj_knowledge` MCP tool as a thin proxy over the existing REST API, runnable on the host via stdio transport for Claude Desktop integration.

Purpose: This is the final interface layer that makes the BBj RAG system accessible to Claude Desktop users. The REST API (Phase 22) handles all search complexity; this MCP server is a formatting layer that translates between MCP protocol and the REST API.

Output: A working MCP server module in the existing `bbj_rag` package, a `bbj-mcp` script entry in pyproject.toml, and a Claude Desktop configuration that spawns the server via `uv run`.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-mcp-server/23-RESEARCH.md

@rag-ingestion/pyproject.toml
@rag-ingestion/src/bbj_rag/api/schemas.py
@rag-ingestion/src/bbj_rag/api/routes.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MCP server module and wire dependencies</name>
  <files>
    rag-ingestion/src/bbj_rag/mcp_server.py
    rag-ingestion/pyproject.toml
  </files>
  <action>
1. Add `mcp` dependency to `pyproject.toml`:
   - Add `"mcp[cli]>=1.25,<2"` to the `dependencies` list (httpx is already present)
   - Add `bbj-mcp = "bbj_rag.mcp_server:main"` to `[project.scripts]`

2. Run `cd rag-ingestion && uv sync` to install the new dependency and verify it resolves.

3. Create `rag-ingestion/src/bbj_rag/mcp_server.py` with:

   **Module docstring:** "BBj Knowledge MCP Server. Thin proxy over the REST API for Claude Desktop."

   **Imports:**
   - `from __future__ import annotations`
   - `logging`, `os`, `sys`
   - `from typing import Literal`
   - `httpx`
   - `from mcp.server.fastmcp import FastMCP`

   **Logging:** Configure logging to stderr ONLY (stdout is JSON-RPC channel):
   ```python
   logging.basicConfig(stream=sys.stderr, level=logging.INFO, format="%(asctime)s [%(name)s] %(message)s")
   logger = logging.getLogger("bbj_mcp")
   ```

   **Config:**
   ```python
   API_BASE = os.environ.get("BBJ_RAG_API_URL", "http://localhost:10800")
   ```

   **FastMCP instance:**
   ```python
   mcp = FastMCP("bbj-knowledge")
   ```

   **`_format_results(data: dict) -> str` function:**
   - Extract `results` list and `query` from response dict
   - If no results: return `"No results found for query: {query}"`
   - For each result, build a text block with:
     - `## Result {i}: {title}` header (append ` [DEPRECATED]` if `deprecated` is true)
     - `*{context_header}*` if present (italic line)
     - Empty line, then `content` text, then empty line
     - `Source: {source_url}`
     - `Generations: {comma-joined list}` if `generations` is non-empty
   - Join blocks with `\n\n---\n\n` separator
   - Prepend `Found {count} results for: {query}\n\n`

   **`search_bbj_knowledge` tool:**
   - Decorated with `@mcp.tool()`
   - Signature: `async def search_bbj_knowledge(query: str, generation: Literal["all", "character", "vpro5", "bbj-gui", "dwc"] | None = None, limit: int = 5) -> str`
   - Use `Literal` type for generation to match Chapter 2's JSON schema enum exactly
   - Docstring: "Search BBj documentation and code examples with generation-aware filtering.\n\nReturns ranked results from the RAG pipeline with source citations.\nUse this to find BBj API references, code patterns, tutorials, and\ndocumentation across all BBj product generations.\n\nArgs:\n    query: Natural language search query about BBj programming.\n    generation: Filter by BBj product generation. Omit for cross-generation search.\n    limit: Maximum number of results (1-50, default 5)."
   - Build payload dict: `{"query": query, "limit": limit}`
   - If `generation` is not None and not "all": add `"generation": generation` to payload
   - Wrap HTTP call in try/except:
     - `httpx.ConnectError` -> return "Error: BBj RAG API is not running.\nStart it with: cd rag-ingestion && docker compose up -d"
     - `httpx.HTTPStatusError` -> return f"Error: REST API returned {exc.response.status_code}"
   - On success: return `_format_results(resp.json())`
   - Use `async with httpx.AsyncClient(timeout=30.0) as client:` for the POST request

   **`main()` function:** (for script entry point)
   ```python
   def main() -> None:
       mcp.run(transport="stdio")
   ```

   **`if __name__ == "__main__":` block:** call `main()`

4. Verify import works: `cd rag-ingestion && uv run python -c "from bbj_rag.mcp_server import mcp; print('OK')"` -- should print OK.

5. Run linting: `cd rag-ingestion && uv run ruff check src/bbj_rag/mcp_server.py` and fix any issues.

6. Run type checking: `cd rag-ingestion && uv run mypy src/bbj_rag/mcp_server.py` and fix any issues. Note: the `mcp` library may not have full type stubs -- if mypy errors are from the mcp library itself, add a `[[tool.mypy.overrides]]` section for `module = "mcp.*"` with `ignore_missing_imports = true` in pyproject.toml.

IMPORTANT: Do NOT use `print()` anywhere in mcp_server.py. All output goes to stderr via logging. stdout is the JSON-RPC communication channel.
  </action>
  <verify>
1. `cd rag-ingestion && uv run python -c "from bbj_rag.mcp_server import mcp; print(type(mcp))"` succeeds
2. `cd rag-ingestion && uv run ruff check src/bbj_rag/mcp_server.py` reports no errors
3. `cd rag-ingestion && uv run mypy src/bbj_rag/mcp_server.py` passes (or passes with overrides for mcp stubs)
4. `cd rag-ingestion && uv pip show mcp` shows version >=1.25,<2
5. `grep "bbj-mcp" rag-ingestion/pyproject.toml` shows the script entry
  </verify>
  <done>
- `mcp_server.py` exists with FastMCP instance, `search_bbj_knowledge` tool with Literal generation enum, `_format_results` formatter, error handling for REST API down, and `main()` entry point
- `pyproject.toml` has `mcp[cli]>=1.25,<2` dependency and `bbj-mcp` script entry
- Import and lint/type-check pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Configure Claude Desktop and verify with MCP Inspector</name>
  <files>
    ~/Library/Application Support/Claude/claude_desktop_config.json
  </files>
  <action>
1. Read the existing `~/Library/Application Support/Claude/claude_desktop_config.json`.

2. Add the `bbj-knowledge` MCP server entry to the existing `mcpServers` object (preserve any existing entries like `chrome-devtools`):
   ```json
   {
     "mcpServers": {
       ...existing entries...,
       "bbj-knowledge": {
         "command": "/Users/beff/.local/bin/uv",
         "args": [
           "--directory",
           "/Users/beff/_workspace/bbj-ai-strategy/rag-ingestion",
           "run",
           "bbj-mcp"
         ],
         "env": {
           "BBJ_RAG_API_URL": "http://localhost:10800"
         }
       }
     }
   }
   ```
   IMPORTANT: Use absolute path for `uv` binary. Verify it exists: `which uv` or `ls /Users/beff/.local/bin/uv`. If the path differs, use the actual path from `which uv`.

3. Verify the `bbj-mcp` script entry works by running it directly (without Docker stack -- should return error message gracefully):
   ```bash
   cd rag-ingestion && echo '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"test","version":"0.1"}}}' | timeout 5 uv run bbj-mcp 2>/dev/null || true
   ```
   This tests that the process starts and responds to JSON-RPC (even if it times out waiting for more input, the process should start without errors).

4. Test with MCP Inspector if npx is available:
   ```bash
   cd /Users/beff/_workspace/bbj-ai-strategy/rag-ingestion && npx @modelcontextprotocol/inspector uv run bbj-mcp
   ```
   The inspector opens a web UI at http://localhost:6274. If the Docker stack is not running, tool invocations will return the graceful error message. If the stack IS running, tool invocations should return formatted search results.

   NOTE: If npx/node is not available, skip this step -- Claude Desktop verification in the checkpoint will suffice.
  </action>
  <verify>
1. `cat ~/Library/Application\ Support/Claude/claude_desktop_config.json` shows `bbj-knowledge` entry with correct absolute paths
2. The `uv run bbj-mcp` command starts without import errors (process starts, reads stdin)
3. The JSON in the config file is valid: `python3 -c "import json; json.load(open('$HOME/Library/Application Support/Claude/claude_desktop_config.json'))"`
  </verify>
  <done>
- `claude_desktop_config.json` contains `bbj-knowledge` server entry with absolute `uv` path and `--directory` pointing to `rag-ingestion`
- Existing MCP server entries (e.g., `chrome-devtools`) are preserved
- `bbj-mcp` script entry resolves and starts the MCP server process
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete MCP server: `search_bbj_knowledge` tool that proxies to the REST API, configured in Claude Desktop via stdio transport, with LLM-optimized text formatting and graceful error handling when the REST API is down.
  </what-built>
  <how-to-verify>
1. Quit and relaunch Claude Desktop completely (Cmd+Q, then reopen)
2. Start a new conversation in Claude Desktop
3. Check that `search_bbj_knowledge` appears in the tool list (click the hammer/tools icon)
4. If the Docker stack is running (`cd rag-ingestion && docker compose up -d`):
   - Ask Claude: "Search BBj documentation for BBjGrid"
   - Verify: Claude invokes the tool and shows formatted results with titles, content, source URLs
   - Ask Claude: "Search BBj documentation for creating a window, filter to DWC generation only"
   - Verify: Results are filtered to DWC generation
5. If the Docker stack is NOT running:
   - Ask Claude: "Search BBj documentation for BBjGrid"
   - Verify: Claude reports the tool returned an error about the API not running, with the docker compose up command
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues with the MCP tool behavior</resume-signal>
</task>

</tasks>

<verification>
Phase 23 is complete when all four requirements are satisfied:

- **MCP-01**: `search_bbj_knowledge` tool matches Chapter 2's JSON schema (query required, generation enum with all/character/vpro5/bbj-gui/dwc, limit with default 5)
- **MCP-02**: MCP server uses stdio transport (`mcp.run(transport="stdio")`) and is spawned by Claude Desktop as a local process
- **MCP-03**: Tool returns formatted text blocks (headers, content, source URLs, generation tags) -- not raw JSON
- **MCP-04**: Tool supports `generation` parameter using `Literal` type that generates the correct JSON schema enum

Automated checks:
```bash
# Verify module exists and imports
cd rag-ingestion && uv run python -c "from bbj_rag.mcp_server import mcp, search_bbj_knowledge; print('imports OK')"

# Verify generation enum in schema (Literal type produces enum in JSON schema)
cd rag-ingestion && uv run python -c "
from bbj_rag.mcp_server import mcp
tools = mcp._tool_manager._tools
tool = tools['search_bbj_knowledge']
schema = tool.parameters
gen_prop = schema['properties']['generation']
assert 'enum' in str(gen_prop) or 'anyOf' in str(gen_prop), 'generation should have enum'
print('schema OK')
"

# Verify no print() calls in module (stdout corruption prevention)
grep -n "print(" rag-ingestion/src/bbj_rag/mcp_server.py && echo "FAIL: print() found" || echo "PASS: no print()"

# Verify logging goes to stderr
grep "stream=sys.stderr" rag-ingestion/src/bbj_rag/mcp_server.py && echo "PASS: stderr logging" || echo "FAIL: missing stderr"

# Verify Claude Desktop config
python3 -c "
import json, os
with open(os.path.expanduser('~/Library/Application Support/Claude/claude_desktop_config.json')) as f:
    cfg = json.load(f)
assert 'bbj-knowledge' in cfg['mcpServers'], 'missing bbj-knowledge'
server = cfg['mcpServers']['bbj-knowledge']
assert 'uv' in server['command'], 'command should be uv'
assert 'bbj-mcp' in server['args'] or 'bbj_rag.mcp_server' in ' '.join(server['args']), 'args should reference mcp server'
print('config OK')
"
```
</verification>

<success_criteria>
1. `search_bbj_knowledge` tool appears in Claude Desktop's tool list after restart
2. Invoking the tool with query "BBjGrid" returns formatted text blocks (not raw JSON) with documentation content, titles, source URLs
3. The tool accepts an optional `generation` parameter that filters results by BBj product generation (generation enum matches Chapter 2: all, character, vpro5, bbj-gui, dwc)
4. MCP server runs on the host via stdio transport, spawned by Claude Desktop, not inside Docker
5. When REST API is not running, the tool returns a clear error message with startup instructions
</success_criteria>

<output>
After completion, create `.planning/phases/23-mcp-server/23-01-SUMMARY.md`
</output>
