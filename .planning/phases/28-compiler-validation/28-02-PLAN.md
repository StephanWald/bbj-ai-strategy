---
phase: 28-compiler-validation
plan: 02
type: execute
wave: 2
depends_on: ["28-01"]
files_modified:
  - rag-ingestion/src/bbj_rag/chat/stream.py
  - rag-ingestion/src/bbj_rag/chat/validation.py
  - rag-ingestion/src/bbj_rag/chat/__init__.py
autonomous: true

must_haves:
  truths:
    - "BBj code blocks in chat responses are validated before being shown to users"
    - "Invalid code triggers automatic fix attempts with error context"
    - "After 3 failed attempts, code is shown with validation warning event"
    - "Validation events are emitted via SSE for frontend consumption"
  artifacts:
    - path: "rag-ingestion/src/bbj_rag/chat/validation.py"
      provides: "Code block extraction and validation loop"
      exports: ["extract_code_blocks", "validate_and_fix_code_blocks", "CodeBlock"]
    - path: "rag-ingestion/src/bbj_rag/chat/stream.py"
      provides: "Modified streaming with validation integration"
      contains: "validation_warning"
  key_links:
    - from: "rag-ingestion/src/bbj_rag/chat/validation.py"
      to: "rag-ingestion/src/bbj_rag/compiler.py"
      via: "import"
      pattern: "from bbj_rag.compiler import"
    - from: "rag-ingestion/src/bbj_rag/chat/stream.py"
      to: "rag-ingestion/src/bbj_rag/chat/validation.py"
      via: "import"
      pattern: "from bbj_rag.chat.validation import"
---

<objective>
Integrate BBj compiler validation into the chat response streaming. Validate BBj code blocks before showing to users, with automatic retry/fix attempts on failure.

Purpose: Ensure engineers never see syntactically invalid BBj code in chat responses (unless validation itself fails). Invalid code triggers Claude to fix it, with up to 3 total attempts.

Output: Modified chat streaming that validates BBj code, attempts fixes, and emits validation_warning events for failed blocks.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-compiler-validation/28-CONTEXT.md
@.planning/phases/28-compiler-validation/28-01-SUMMARY.md
@rag-ingestion/src/bbj_rag/chat/stream.py
@rag-ingestion/src/bbj_rag/chat/prompt.py
@rag-ingestion/src/bbj_rag/compiler.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create chat validation module with code block extraction</name>
  <files>
    rag-ingestion/src/bbj_rag/chat/validation.py
    rag-ingestion/src/bbj_rag/chat/__init__.py
  </files>
  <action>
Create `rag-ingestion/src/bbj_rag/chat/validation.py` with:

1. **CodeBlock dataclass:**
   ```python
   @dataclass
   class CodeBlock:
       code: str
       language: str | None  # From fence (```bbj, ```basic, or None)
       start_pos: int  # Position in original text
       end_pos: int
       is_bbj: bool  # Determined by language tag or detection
       validation_result: ValidationResult | None = None
       attempts: int = 0
   ```

2. **extract_code_blocks(text: str) -> list[CodeBlock]:**
   - Use regex to find all fenced code blocks: ` ```(\w*)\n(.*?)``` `
   - For each block:
     - Extract language tag (if any)
     - Extract code content
     - Record start/end positions
     - Determine is_bbj:
       - `True` if language tag is `bbj` or `basic`
       - `True` if no/generic tag AND detect_bbj_code() returns True
       - `False` otherwise
   - Return list of CodeBlock objects
   - Important: Must handle nested backticks in code (rare but possible)

3. **async validate_code_blocks(blocks: list[CodeBlock], timeout: float = 10.0) -> list[CodeBlock]:**
   - For each block where is_bbj is True:
     - Call validate_bbj_syntax(block.code, timeout)
     - Store result in block.validation_result
     - Increment block.attempts
   - Return updated blocks

4. **build_fix_prompt(code: str, errors: str) -> str:**
   - Create a prompt asking Claude to fix the BBj code
   - Include the original code and the compiler errors
   - Be specific: "Fix the following BBj syntax errors. Return ONLY the corrected code, no explanations."
   ```
   The following BBj code has syntax errors:

   ```bbj
   {code}
   ```

   Compiler errors:
   {errors}

   Please fix the syntax errors and return ONLY the corrected BBj code. Do not include explanations or markdown formatting.
   ```

5. **replace_code_block(text: str, old_block: CodeBlock, new_code: str) -> str:**
   - Replace the code block at old_block's position with new_code
   - Preserve the language tag and fence formatting
   - Return modified text

Update `rag-ingestion/src/bbj_rag/chat/__init__.py` to export the new module's public functions.
  </action>
  <verify>
```bash
cd /Users/beff/_workspace/bbj-ai-strategy/rag-ingestion && uv run python -c "
from bbj_rag.chat.validation import extract_code_blocks, CodeBlock

# Test extraction
text = '''Here is some code:

\`\`\`bbj
print \"Hello\"
\`\`\`

And some Python:

\`\`\`python
print('hello')
\`\`\`

And unmarked BBj:

\`\`\`
rem This is BBj
print \"test\"
\`\`\`
'''

blocks = extract_code_blocks(text)
print(f'Found {len(blocks)} code blocks')
for b in blocks:
    print(f'  lang={b.language}, is_bbj={b.is_bbj}, code={b.code[:20]!r}...')

assert len(blocks) == 3
assert blocks[0].is_bbj == True  # bbj tag
assert blocks[1].is_bbj == False  # python tag
assert blocks[2].is_bbj == True  # detected as BBj
print('Extraction tests passed!')
"
```
  </verify>
  <done>
validation.py exists with extract_code_blocks() that correctly identifies BBj code blocks by language tag or content detection. CodeBlock dataclass tracks position, language, BBj detection status, and validation state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate validation loop into chat streaming</name>
  <files>
    rag-ingestion/src/bbj_rag/chat/stream.py
  </files>
  <action>
Modify `stream_chat_response()` in stream.py to validate BBj code and attempt fixes:

**Architecture change:** Instead of streaming directly from Claude, we need to:
1. Collect the full response
2. Extract and validate BBj code blocks
3. For invalid blocks, ask Claude to fix them (up to 3 total attempts)
4. Stream the final validated response with any validation warnings

**New flow:**

```python
async def stream_chat_response(...) -> AsyncIterator[dict[str, Any]]:
    # ... existing setup ...

    # Phase 1: Get initial response (collected, not streamed yet)
    initial_response = await _get_claude_response(client, settings, system_prompt, truncated)

    # Phase 2: Validate and fix BBj code blocks
    validated_response, warnings = await _validate_response_code(
        client, settings, system_prompt, truncated, initial_response, max_attempts=3
    )

    # Phase 3: Emit sources
    yield {"event": "sources", "data": json.dumps(sources_list)}

    # Phase 4: Emit validation warnings (if any)
    for warning in warnings:
        yield {
            "event": "validation_warning",
            "data": json.dumps(warning),
        }

    # Phase 5: Stream the validated response as deltas (simulate streaming for UX)
    # Split into chunks and yield with small delays for visual effect
    for chunk in _split_into_chunks(validated_response, chunk_size=50):
        yield {"event": "delta", "data": json.dumps({"text": chunk})}
        await asyncio.sleep(0.01)  # Small delay for streaming feel

    # Phase 6: Done
    yield {"event": "done", "data": json.dumps({...})}
```

**Helper functions to add:**

1. **async _get_claude_response(client, settings, system_prompt, messages) -> str:**
   - Call Claude API with `stream=False` (non-streaming for validation)
   - Return the full response text

2. **async _validate_response_code(client, settings, system_prompt, messages, response, max_attempts) -> tuple[str, list[dict]]:**
   - Extract code blocks from response
   - For each BBj block:
     - Validate with bbjcpl
     - If invalid and attempts < max_attempts:
       - Build fix prompt with error
       - Ask Claude to fix the code (new API call)
       - Replace block in response with fixed code
       - Re-validate
     - If still invalid after max_attempts:
       - Add to warnings list: `{"code_index": N, "errors": stderr}`
   - Return (final_response, warnings_list)

3. **_split_into_chunks(text: str, chunk_size: int) -> Iterator[str]:**
   - Split text into chunks for simulated streaming
   - Prefer splitting at word boundaries

**Warning dict structure:**
```python
{
    "code_index": 1,  # Which code block (1-indexed for display)
    "errors": "bbjcpl stderr content",
    "code_preview": "first 50 chars of code...",
}
```

**Important considerations:**
- Keep the existing streaming for sources event at the start
- Validation happens BEFORE response is streamed to user
- User sees a slightly longer initial wait but gets validated code
- If bbjcpl unavailable/times out, add warning and continue (don't block)
- Non-BBj code blocks pass through unchanged
  </action>
  <verify>
Start the server and test with a chat request that should trigger validation:
```bash
# Start server in background (if not running)
cd /Users/beff/_workspace/bbj-ai-strategy/rag-ingestion && docker compose up -d

# Test chat endpoint (requires ANTHROPIC_API_KEY)
curl -X POST http://localhost:10800/chat/stream \
  -H "Content-Type: application/json" \
  -d '{"messages":[{"role":"user","content":"Show me how to print Hello World in BBj"}]}' \
  --no-buffer 2>&1 | head -50

# Look for:
# - "sources" event
# - "validation_warning" events (if code was invalid)
# - "delta" events with response content
# - "done" event
```
  </verify>
  <done>
Chat streaming validates BBj code blocks before showing to users. Invalid code triggers automatic fix attempts. After max attempts, validation_warning events are emitted with compiler errors. Valid code appears without any indicator (silent success).
  </done>
</task>

</tasks>

<verification>
1. Code block extraction correctly identifies BBj blocks
2. Validation runs bbjcpl on extracted BBj code
3. Fix attempts happen when validation fails
4. validation_warning events are emitted for persistently invalid code
5. Valid code blocks have no special treatment (silent success)

End-to-end test:
```bash
# Test the full flow with docker compose
cd /Users/beff/_workspace/bbj-ai-strategy/rag-ingestion

# Ensure services are up
docker compose up -d

# Send a chat request that will likely include BBj code
curl -X POST http://localhost:10800/chat/stream \
  -H "Content-Type: application/json" \
  -d '{"messages":[{"role":"user","content":"Show me BBj code to create a window and add a button"}]}' \
  --no-buffer 2>&1 | grep -E "^(event:|data:)" | head -30
```
</verification>

<success_criteria>
- validation.py exists with extract_code_blocks(), validate_code_blocks()
- stream.py modified to validate BBj code before streaming
- Fix attempts happen automatically (up to 3 total)
- validation_warning SSE events emitted for failed blocks
- Valid code shown without any indicator
- bbjcpl timeout/unavailable handled gracefully with warning
</success_criteria>

<output>
After completion, create `.planning/phases/28-compiler-validation/28-02-SUMMARY.md`
</output>
