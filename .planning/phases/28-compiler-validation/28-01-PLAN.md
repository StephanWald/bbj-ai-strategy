---
phase: 28-compiler-validation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rag-ingestion/src/bbj_rag/compiler.py
  - rag-ingestion/src/bbj_rag/mcp_server.py
  - rag-ingestion/src/bbj_rag/config.py
autonomous: true

must_haves:
  truths:
    - "validate_bbj_syntax() returns success for valid BBj code"
    - "validate_bbj_syntax() returns errors from bbjcpl stderr for invalid BBj code"
    - "validate_bbj_syntax MCP tool is callable from Claude Desktop"
    - "Validation times out after 10 seconds"
  artifacts:
    - path: "rag-ingestion/src/bbj_rag/compiler.py"
      provides: "BBj compiler validation module"
      exports: ["validate_bbj_syntax", "ValidationResult", "detect_bbj_code"]
    - path: "rag-ingestion/src/bbj_rag/mcp_server.py"
      provides: "validate_bbj_syntax MCP tool"
      contains: "@mcp.tool"
  key_links:
    - from: "rag-ingestion/src/bbj_rag/compiler.py"
      to: "bbjcpl"
      via: "asyncio.subprocess"
      pattern: "create_subprocess_exec.*bbjcpl"
    - from: "rag-ingestion/src/bbj_rag/mcp_server.py"
      to: "rag-ingestion/src/bbj_rag/compiler.py"
      via: "import"
      pattern: "from bbj_rag.compiler import"
---

<objective>
Create the BBj compiler validation foundation: a module that validates BBj code via bbjcpl subprocess, and expose it as an MCP tool for Claude Desktop.

Purpose: Enable programmatic validation of BBj code snippets against the real compiler. This is the foundation for automatic validation in chat responses (Plan 02).

Output: Working compiler.py module with validate_bbj_syntax(), detect_bbj_code() functions, and validate_bbj_syntax MCP tool.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-compiler-validation/28-CONTEXT.md
@rag-ingestion/src/bbj_rag/mcp_server.py
@rag-ingestion/src/bbj_rag/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create compiler validation module</name>
  <files>
    rag-ingestion/src/bbj_rag/compiler.py
    rag-ingestion/src/bbj_rag/config.py
  </files>
  <action>
Create `rag-ingestion/src/bbj_rag/compiler.py` with:

1. **ValidationResult dataclass:**
   ```python
   @dataclass
   class ValidationResult:
       valid: bool
       errors: str  # Raw bbjcpl stderr output
       timed_out: bool = False
       unavailable: bool = False  # bbjcpl not found
   ```

2. **detect_bbj_code(code: str) -> bool function:**
   Heuristics to identify BBj code:
   - Lowercase BBj keywords: `rem`, `let`, `print`, `open`, `close`, `read`, `write`, `input`, `if`, `then`, `else`, `endif`, `while`, `wend`, `for`, `next`, `gosub`, `return`, `end`, `dim`, `def`, `fn`, `call`, `enter`, `exit`, `begin`, `process_events`, `setcallback`
   - BBj-specific patterns: `! comment` at line start, `#\d+` channel syntax, `::` scope operator, `BBj` prefix
   - Return True if 2+ BBj indicators found (avoids false positives on generic BASIC)
   - Be conservative: better to try validation and let bbjcpl decide

3. **async validate_bbj_syntax(code: str, timeout: float = 10.0) -> ValidationResult:**
   - Create temp file with `.bbj` extension in system temp dir
   - Run `bbjcpl -N <tempfile>` as subprocess
   - Wait up to `timeout` seconds
   - Read stderr (bbjcpl always exits 0, errors in stderr)
   - Parse stderr: empty = valid, non-empty = errors
   - Clean up temp file
   - Handle cases:
     - Success: `ValidationResult(valid=True, errors="")`
     - Errors: `ValidationResult(valid=False, errors=stderr_content)`
     - Timeout: `ValidationResult(valid=False, errors="", timed_out=True)`
     - bbjcpl not found: `ValidationResult(valid=False, errors="", unavailable=True)`

4. **Add config setting:**
   Add to `Settings` class in config.py:
   - `compiler_timeout: float = Field(default=10.0)` - configurable timeout
   - `compiler_path: str = Field(default="bbjcpl")` - path to bbjcpl binary

Key implementation notes:
- Use `asyncio.create_subprocess_exec` for async subprocess
- Use `tempfile.NamedTemporaryFile` with `delete=False`, then cleanup manually
- bbjcpl path configurable via BBJ_RAG_COMPILER_PATH env var (engineers may have it in different locations)
- Check `FileNotFoundError` when spawning subprocess to detect missing bbjcpl
  </action>
  <verify>
Create a simple test script that imports the module and validates both valid and invalid BBj code:
```bash
cd /Users/beff/_workspace/bbj-ai-strategy/rag-ingestion && uv run python -c "
import asyncio
from bbj_rag.compiler import validate_bbj_syntax, detect_bbj_code

# Test detection
assert detect_bbj_code('print \"hello\"') == True
assert detect_bbj_code('console.log(\"hello\")') == False

# Test validation (requires bbjcpl on host)
async def test():
    good = await validate_bbj_syntax('print \"hello\"')
    print(f'Valid code: valid={good.valid}, errors={good.errors!r}')
    bad = await validate_bbj_syntax('print \"hello')  # unclosed string
    print(f'Invalid code: valid={bad.valid}, errors={bad.errors!r}')
asyncio.run(test())
"
```
  </verify>
  <done>
compiler.py exists with validate_bbj_syntax() and detect_bbj_code() functions. Valid BBj code returns ValidationResult(valid=True). Invalid BBj code returns ValidationResult(valid=False) with bbjcpl stderr in errors field.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add validate_bbj_syntax MCP tool</name>
  <files>
    rag-ingestion/src/bbj_rag/mcp_server.py
  </files>
  <action>
Add a new MCP tool `validate_bbj_syntax` to mcp_server.py:

```python
@mcp.tool()
async def validate_bbj_syntax(code: str) -> str:
    """Validate BBj code syntax using the bbjcpl compiler.

    Runs the code through bbjcpl -N (syntax check only, no output file).
    Returns whether the code compiled successfully, with error details if not.

    NOTE: bbjcpl must be installed and accessible on the host system.
    The compiler always exits 0; errors are reported via stderr.

    Args:
        code: BBj source code to validate (can be a snippet or full program).

    Returns:
        Validation result indicating success or failure with error details.
    """
    from bbj_rag.compiler import validate_bbj_syntax as do_validate

    result = await do_validate(code)

    if result.unavailable:
        return (
            "Validation unavailable: bbjcpl compiler not found.\n"
            "Ensure BBj is installed and bbjcpl is in PATH, or set "
            "BBJ_RAG_COMPILER_PATH environment variable."
        )

    if result.timed_out:
        return "Validation timed out after 10 seconds."

    if result.valid:
        return "Valid: BBj code compiled successfully with no syntax errors."

    return f"Invalid: BBj compilation failed.\n\nCompiler output:\n{result.errors}"
```

The tool:
- Accepts BBj code string
- Returns human-readable validation result
- Provides actionable guidance when bbjcpl unavailable
- Shows full compiler stderr on failure

Note: Import the compiler module inside the function to avoid import-time dependency issues (the module uses asyncio which may not be initialized at import time).
  </action>
  <verify>
Test the MCP tool by calling it directly:
```bash
cd /Users/beff/_workspace/bbj-ai-strategy/rag-ingestion && uv run python -c "
import asyncio
from bbj_rag.mcp_server import validate_bbj_syntax

async def test():
    # Valid code
    result = await validate_bbj_syntax('print \"Hello World\"')
    print('Valid test:', result[:50])

    # Invalid code
    result = await validate_bbj_syntax('print \"unclosed')
    print('Invalid test:', result[:100])

asyncio.run(test())
"
```
  </verify>
  <done>
validate_bbj_syntax MCP tool is registered and callable. Returns "Valid: ..." for correct BBj code, "Invalid: ..." with compiler errors for broken code, or guidance when bbjcpl unavailable.
  </done>
</task>

</tasks>

<verification>
1. compiler.py module imports without error
2. detect_bbj_code() correctly identifies BBj vs non-BBj code
3. validate_bbj_syntax() returns ValidationResult with correct fields
4. Valid BBj code validates successfully
5. Invalid BBj code returns errors from bbjcpl stderr
6. MCP tool is accessible via mcp_server module
7. MCP tool returns human-readable results

Run full verification:
```bash
cd /Users/beff/_workspace/bbj-ai-strategy/rag-ingestion && uv run python -c "
import asyncio
from bbj_rag.compiler import validate_bbj_syntax, detect_bbj_code, ValidationResult
from bbj_rag.mcp_server import validate_bbj_syntax as mcp_validate

# Detection tests
assert detect_bbj_code('print \"test\"') == True, 'Should detect BBj'
assert detect_bbj_code('for i = 1 to 10; print i; next i') == True, 'Should detect BBj loop'
assert detect_bbj_code('const x = 1;') == False, 'Should not detect JS'

async def test():
    # Direct validation
    result = await validate_bbj_syntax('rem Test\nprint \"Hello\"')
    assert isinstance(result, ValidationResult)
    print(f'Direct validation: valid={result.valid}')

    # MCP tool
    text = await mcp_validate('print \"Hello\"')
    assert 'Valid' in text or 'unavailable' in text.lower()
    print(f'MCP tool result: {text[:60]}...')

asyncio.run(test())
print('All verifications passed!')
"
```
</verification>

<success_criteria>
- compiler.py exists with ValidationResult, detect_bbj_code(), validate_bbj_syntax()
- MCP server has validate_bbj_syntax tool registered
- Valid BBj code -> ValidationResult(valid=True)
- Invalid BBj code -> ValidationResult(valid=False, errors=<stderr>)
- Timeout -> ValidationResult(timed_out=True)
- Missing bbjcpl -> ValidationResult(unavailable=True)
- MCP tool returns human-readable strings
</success_criteria>

<output>
After completion, create `.planning/phases/28-compiler-validation/28-01-SUMMARY.md`
</output>
