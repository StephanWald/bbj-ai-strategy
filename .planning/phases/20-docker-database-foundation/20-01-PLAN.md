---
phase: 20-docker-database-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rag-ingestion/docker-compose.yml
  - rag-ingestion/Dockerfile
  - rag-ingestion/.env.example
  - rag-ingestion/scripts/reset-db.sh
  - rag-ingestion/pyproject.toml
  - rag-ingestion/src/bbj_rag/app.py
  - rag-ingestion/src/bbj_rag/health.py
autonomous: true

must_haves:
  truths:
    - "`docker compose config` validates the compose file without errors"
    - "`docker build` succeeds for the app container image"
    - ".env.example documents all required environment variables"
    - "/health endpoint definition exists in the FastAPI app"
    - "fastapi and uvicorn are declared as project dependencies"
  artifacts:
    - path: "rag-ingestion/docker-compose.yml"
      provides: "Service orchestration for db and app containers"
      contains: "pgvector/pgvector:0.8.0-pg17"
    - path: "rag-ingestion/Dockerfile"
      provides: "Multi-stage Python app image with uv"
      contains: "ghcr.io/astral-sh/uv"
    - path: "rag-ingestion/.env.example"
      provides: "Documented environment variable template"
      contains: "BBJ_RAG_DB_PASSWORD"
    - path: "rag-ingestion/scripts/reset-db.sh"
      provides: "Database wipe and reinitialize script"
      contains: "rm -rf ./pgdata"
    - path: "rag-ingestion/src/bbj_rag/app.py"
      provides: "FastAPI application entrypoint"
      contains: "FastAPI"
    - path: "rag-ingestion/src/bbj_rag/health.py"
      provides: "Health check endpoint with DB and Ollama checks"
      contains: "/health"
  key_links:
    - from: "rag-ingestion/docker-compose.yml"
      to: "rag-ingestion/Dockerfile"
      via: "build context"
      pattern: "build:\\s*\\."
    - from: "rag-ingestion/docker-compose.yml"
      to: "rag-ingestion/.env"
      via: "env_file directive"
      pattern: "env_file"
    - from: "rag-ingestion/docker-compose.yml"
      to: "rag-ingestion/sql/schema.sql"
      via: "volume mount into docker-entrypoint-initdb.d"
      pattern: "initdb"
    - from: "rag-ingestion/src/bbj_rag/app.py"
      to: "rag-ingestion/src/bbj_rag/health.py"
      via: "router include"
      pattern: "include_router|health"
---

<objective>
Create the Docker infrastructure files (Compose, Dockerfile, env template, reset script) and the minimal FastAPI application with health endpoint. After this plan, `docker compose config` validates, `docker build` succeeds, and the app skeleton exists with /health ready.

Purpose: Establish the container infrastructure that Plan 02 will wire up with config refactoring, startup logic, and volume mounts.
Output: docker-compose.yml, Dockerfile, .env.example, reset-db.sh, app.py, health.py, updated pyproject.toml
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-docker-database-foundation/20-CONTEXT.md
@.planning/phases/20-docker-database-foundation/20-RESEARCH.md

# Key existing files
@rag-ingestion/pyproject.toml
@rag-ingestion/sql/schema.sql
@rag-ingestion/src/bbj_rag/config.py
@rag-ingestion/src/bbj_rag/db.py
@rag-ingestion/src/bbj_rag/schema.py
@rag-ingestion/src/bbj_rag/embedder.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Docker Compose + Dockerfile + env template + reset script</name>
  <files>
    rag-ingestion/docker-compose.yml
    rag-ingestion/Dockerfile
    rag-ingestion/.env.example
    rag-ingestion/scripts/reset-db.sh
  </files>
  <action>
Create four new files in the `rag-ingestion/` directory:

**docker-compose.yml** -- Two services: `db` and `app`.

`db` service:
- Image: `pgvector/pgvector:0.8.0-pg17`
- Restart: `unless-stopped`
- `shm_size: 256mb` (for HNSW index builds)
- Environment: `POSTGRES_USER`, `POSTGRES_PASSWORD`, `POSTGRES_DB` from env vars `${BBJ_RAG_DB_USER}`, `${BBJ_RAG_DB_PASSWORD}`, `${BBJ_RAG_DB_NAME}`
- Ports: `${DB_PORT_EXTERNAL:-10432}:5432`
- Volumes: `./pgdata:/var/lib/postgresql/data` (bind mount for inspectability), `./sql/schema.sql:/docker-entrypoint-initdb.d/01-schema.sql:ro` (first-run schema init)
- Healthcheck: `pg_isready -U ${BBJ_RAG_DB_USER:-bbj} -d ${BBJ_RAG_DB_NAME:-bbj_rag}` with interval 5s, timeout 5s, retries 5, start_period 10s

`app` service:
- Build context: `.` (current directory)
- Restart: `unless-stopped`
- `depends_on: db: condition: service_healthy, restart: true`
- `env_file: - path: .env, required: true`
- Environment overrides: `BBJ_RAG_DB_HOST=db`, `OLLAMA_HOST=http://host.docker.internal:11434`
- Ports: `${APP_PORT_EXTERNAL:-10800}:8000`
- Volumes: `${INGESTION_DATA_PATH:-./_data}:/data:ro` (source data, read-only)
- `extra_hosts: - "host.docker.internal:host-gateway"` (Linux compatibility)
- Healthcheck: `curl -f http://localhost:8000/health` with interval 10s, timeout 5s, retries 3, start_period 15s

**Dockerfile** -- Multi-stage build following the uv Docker pattern from research:

Stage 1 (builder):
- FROM `python:3.12-slim-bookworm AS builder`
- `COPY --from=ghcr.io/astral-sh/uv:0.6.6 /uv /uvx /bin/` (pin to a known stable 0.6.x release -- check the current uv.lock or use 0.6.6 if unsure)
- ENV: `UV_COMPILE_BYTECODE=1`, `UV_LINK_MODE=copy`, `UV_NO_DEV=1`
- WORKDIR `/app`
- First RUN: `--mount=type=cache,target=/root/.cache/uv --mount=type=bind,source=uv.lock,target=uv.lock --mount=type=bind,source=pyproject.toml,target=pyproject.toml uv sync --frozen --no-install-project`
- COPY `. /app`
- Second RUN: `--mount=type=cache,target=/root/.cache/uv uv sync --frozen`

Stage 2 (runtime):
- FROM `python:3.12-slim-bookworm`
- Install curl: `RUN apt-get update && apt-get install -y --no-install-recommends curl && rm -rf /var/lib/apt/lists/*`
- WORKDIR `/app`
- `COPY --from=builder /app /app`
- `ENV PATH="/app/.venv/bin:$PATH"`
- EXPOSE 8000
- CMD: `["uvicorn", "bbj_rag.app:app", "--host", "0.0.0.0", "--port", "8000"]`

**IMPORTANT for Dockerfile:** The uv version should match what the project is actually using. Check the current `uv.lock` file header or `Makefile` for version hints. If unclear, use `0.6.6` as the pin. The version must be a specific tag, not `latest`.

**.env.example** -- Template with all required vars, documented with comments:
- `BBJ_RAG_DB_HOST=localhost` (overridden to `db` in compose)
- `BBJ_RAG_DB_PORT=5432`
- `BBJ_RAG_DB_USER=bbj`
- `BBJ_RAG_DB_PASSWORD=changeme`
- `BBJ_RAG_DB_NAME=bbj_rag`
- `OLLAMA_HOST=http://host.docker.internal:11434`
- `BBJ_RAG_EMBEDDING_MODEL=qwen3-embedding:0.6b`
- `BBJ_RAG_EMBEDDING_DIMENSIONS=1024`
- `BBJ_RAG_EMBEDDING_PROVIDER=ollama`
- `ENV=production`
- `APP_PORT_EXTERNAL=10800`
- `DB_PORT_EXTERNAL=10432`
- `INGESTION_DATA_PATH=./data`

Also add `POSTGRES_USER`, `POSTGRES_PASSWORD`, `POSTGRES_DB` mapped from the BBJ_RAG vars using `${BBJ_RAG_DB_USER}` syntax (or duplicate the values -- compose interpolation of .env cross-references may not work, so just set them explicitly: `POSTGRES_USER=bbj`, `POSTGRES_PASSWORD=changeme`, `POSTGRES_DB=bbj_rag`).

Add comments explaining: (1) copy this file to `.env` before running, (2) Ollama must be running on host with `OLLAMA_HOST=0.0.0.0:11434`, (3) port mapping rationale.

**scripts/reset-db.sh** -- Executable shell script:
- `#!/usr/bin/env bash`
- `set -euo pipefail`
- Stops containers (`docker compose down`)
- Removes `./pgdata` directory
- Starts fresh (`docker compose up -d`)
- Waits for healthy state with a simple poll loop (sleep + curl to health endpoint)
- Prints "Reset complete."

Also add `.env` and `pgdata/` to the `.gitignore` file (append to existing gitignore or create `rag-ingestion/.gitignore`).
  </action>
  <verify>
Run from `rag-ingestion/` directory:
- `docker compose config` -- must complete without errors (validates YAML and variable interpolation; copy .env.example to .env first)
- `test -x scripts/reset-db.sh` -- reset script is executable
- `cat .env.example | grep BBJ_RAG_DB_PASSWORD` -- password var documented
  </verify>
  <done>
docker-compose.yml defines db (pgvector 0.8.0-pg17) and app services with health checks, restart policies, volume mounts, and env_file. Dockerfile uses multi-stage uv build. .env.example documents all required vars. reset-db.sh is executable. pgdata/ and .env are gitignored.
  </done>
</task>

<task type="auto">
  <name>Task 2: FastAPI app + health endpoint + dependency additions</name>
  <files>
    rag-ingestion/pyproject.toml
    rag-ingestion/src/bbj_rag/app.py
    rag-ingestion/src/bbj_rag/health.py
  </files>
  <action>
**pyproject.toml** -- Add two new dependencies to the `dependencies` list:
- `"fastapi>=0.115,<1"`
- `"uvicorn[standard]>=0.34,<1"`

Do NOT change any other dependencies or configuration.

**src/bbj_rag/health.py** -- New module with the `/health` endpoint:

Create an APIRouter (not a standalone FastAPI app) with a single `GET /health` endpoint.

The endpoint checks two dependencies:
1. **Database**: Connect using `psycopg.connect()` with keyword args (`host`, `port`, `user`, `password`, `dbname`) from Settings. Execute `SELECT 1`. Close connection. Report "ok" or "error: {message}".
2. **Ollama**: Use `httpx.AsyncClient` to GET `{OLLAMA_HOST}/api/tags` with 5-second timeout. Report "ok" or "error: {message}".

Return JSON: `{"status": "healthy"|"degraded", "checks": {"database": "ok"|"error: ...", "ollama": "ok"|"error: ..."}}`

Status is "healthy" when all checks pass, "degraded" otherwise. Return HTTP 200 when healthy, 503 when degraded (important for Docker HEALTHCHECK to detect failures via `curl -f`).

Import Settings from `bbj_rag.config` and read `OLLAMA_HOST` from `os.environ` (with default `http://127.0.0.1:11434`).

**IMPORTANT:** For the database check, the health endpoint needs the separate DB fields that Plan 02 will add to Settings. For now, use `settings.database_url` (the existing field) for the connection. Plan 02 will refactor this to use separate keyword args. This avoids a circular dependency.

**src/bbj_rag/app.py** -- New module, the FastAPI application entrypoint:

Create a FastAPI instance with `title="BBJ RAG"`. Include the health router. This is a minimal skeleton -- Plan 02 will add the lifespan handler with schema application and startup summary.

```python
from fastapi import FastAPI
from bbj_rag.health import router as health_router

app = FastAPI(title="BBJ RAG")
app.include_router(health_router)
```

After creating these files, run `uv sync` from the rag-ingestion directory to install the new dependencies and update uv.lock.
  </action>
  <verify>
Run from `rag-ingestion/` directory:
- `uv sync` -- installs successfully with new deps
- `uv run python -c "from bbj_rag.app import app; print(app.title)"` -- prints "BBJ RAG"
- `uv run python -c "from bbj_rag.health import router; print(router.routes)"` -- shows health route
- `uv run pytest tests/ -x -q` -- existing tests still pass (no regressions from dependency additions)
  </verify>
  <done>
FastAPI app exists at `bbj_rag.app:app` with /health endpoint included. pyproject.toml has fastapi and uvicorn dependencies. uv.lock updated. Existing tests pass.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `docker compose config` validates without errors (from rag-ingestion/ with .env copied from .env.example)
2. `docker build -t bbj-rag-test .` succeeds from rag-ingestion/ directory
3. `uv run python -c "from bbj_rag.app import app; print(app.title)"` prints "BBJ RAG"
4. `uv run pytest tests/ -x -q` passes (no regressions)
5. `.env.example` contains all documented env vars
6. `scripts/reset-db.sh` is executable
</verification>

<success_criteria>
- Docker infrastructure files exist and validate
- FastAPI app skeleton is importable with /health route
- New dependencies installed without breaking existing code
- Reset script is executable and documented
- .env and pgdata are gitignored
</success_criteria>

<output>
After completion, create `.planning/phases/20-docker-database-foundation/20-01-SUMMARY.md`
</output>
