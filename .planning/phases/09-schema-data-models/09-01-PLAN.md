---
phase: 09-schema-data-models
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rag-ingestion/pyproject.toml
  - rag-ingestion/src/bbj_rag/models.py
  - rag-ingestion/src/bbj_rag/config.py
  - rag-ingestion/config.toml
  - rag-ingestion/tests/test_models.py
  - rag-ingestion/tests/test_config.py
autonomous: true

must_haves:
  truths:
    - "Pydantic Document model validates parsed content with source_url, title, doc_type, content, generations and rejects empty content or missing generations"
    - "Pydantic Chunk model auto-computes SHA-256 content_hash via from_content() factory and carries optional embedding vector"
    - "Configuration loads database_url, embedding settings, chunk sizes, and source paths from config.toml with BBJ_RAG_ env var overrides"
    - "No hardcoded database URLs, model names, or chunk sizes exist in any Python module"
  artifacts:
    - path: "rag-ingestion/src/bbj_rag/models.py"
      provides: "Document and Chunk Pydantic models with validation and content hashing"
      exports: ["Document", "Chunk"]
    - path: "rag-ingestion/src/bbj_rag/config.py"
      provides: "Settings class loading from TOML + env vars"
      exports: ["Settings"]
    - path: "rag-ingestion/config.toml"
      provides: "Default configuration values for all pipeline settings"
    - path: "rag-ingestion/tests/test_models.py"
      provides: "Unit tests for Document/Chunk validation and content hashing"
    - path: "rag-ingestion/tests/test_config.py"
      provides: "Unit tests for config loading and env var override"
  key_links:
    - from: "rag-ingestion/src/bbj_rag/models.py"
      to: "hashlib.sha256"
      via: "Chunk.from_content() factory method"
      pattern: "hashlib\\.sha256.*encode.*hexdigest"
    - from: "rag-ingestion/src/bbj_rag/config.py"
      to: "rag-ingestion/config.toml"
      via: "pydantic-settings TomlConfigSettingsSource"
      pattern: "TomlConfigSettingsSource"
---

<objective>
Define the Pydantic data models (Document, Chunk), configuration system (pydantic-settings with TOML), and content-hash deduplication that form the stable contracts for all downstream pipeline components.

Purpose: Every parser, tagger, and embedder in the pipeline depends on these data contracts. Defining them first — with validation and tests — prevents interface drift and catches malformed data at the boundary rather than in database insert failures.

Output: models.py, config.py, config.toml, pyproject.toml with runtime deps, and unit tests proving validation works.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-schema-data-models/09-RESEARCH.md
@.planning/phases/08-project-scaffold-readme/08-01-SUMMARY.md
@rag-ingestion/pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add runtime dependencies and create Pydantic data models</name>
  <files>
    rag-ingestion/pyproject.toml
    rag-ingestion/src/bbj_rag/models.py
  </files>
  <action>
1. Update `rag-ingestion/pyproject.toml` — add runtime dependencies to the `dependencies` array:
   ```toml
   dependencies = [
       "psycopg[binary]>=3.3,<4",
       "pgvector>=0.4,<0.5",
       "pydantic>=2.12,<3",
       "pydantic-settings>=2.12,<3",
   ]
   ```
   Run `cd rag-ingestion && uv sync` to install and update the lockfile.

2. Create `rag-ingestion/src/bbj_rag/models.py` with:

   **Document model** (parser output contract):
   - Fields: `source_url: str`, `title: str`, `doc_type: str`, `content: str`, `generations: list[str]`, `metadata: dict[str, str] = Field(default_factory=dict)`
   - `model_config = ConfigDict(extra="forbid", str_strip_whitespace=True)`
   - `@field_validator("content")` — reject empty/whitespace-only content with `ValueError("content must not be empty")`
   - `@field_validator("generations")` — reject empty list with `ValueError("generations must contain at least one entry")`

   **Chunk model** (storage-ready contract):
   - Fields: `source_url: str`, `title: str`, `doc_type: str`, `content: str`, `content_hash: str`, `generations: list[str]`, `metadata: dict[str, str] = Field(default_factory=dict)`, `embedding: list[float] | None = None`
   - `model_config = ConfigDict(extra="forbid", str_strip_whitespace=True)`
   - `@classmethod from_content(cls, source_url, title, doc_type, content, generations, metadata=None) -> Chunk` — computes `content_hash` as `hashlib.sha256(content.strip().encode("utf-8")).hexdigest()` and constructs the Chunk. This is the ONLY way chunks should be created (ensures hash consistency).
   - Same validators as Document for content and generations.

   Import `hashlib` from stdlib, `BaseModel, ConfigDict, Field, field_validator` from pydantic.

   **Critical:** Hash is computed on `content.strip()` (normalized) to avoid whitespace-only differences causing duplicate rows.
  </action>
  <verify>
    Run `cd rag-ingestion && uv sync` succeeds without errors.
    Run `cd rag-ingestion && uv run python -c "from bbj_rag.models import Document, Chunk; print('OK')"` prints OK.
    Run `cd rag-ingestion && uv run python -c "from bbj_rag.models import Chunk; c = Chunk.from_content('http://x', 'T', 'web', 'hello', ['BBj 25']); print(c.content_hash)"` prints the SHA-256 of "hello".
  </verify>
  <done>Document and Chunk models importable, validators enforce non-empty content and non-empty generations, Chunk.from_content() produces deterministic content hashes.</done>
</task>

<task type="auto">
  <name>Task 2: Create configuration system with TOML and env var support</name>
  <files>
    rag-ingestion/src/bbj_rag/config.py
    rag-ingestion/config.toml
  </files>
  <action>
1. Create `rag-ingestion/src/bbj_rag/config.py` with a `Settings` class:

   ```python
   from pathlib import Path
   from pydantic import Field
   from pydantic_settings import BaseSettings, SettingsConfigDict, TomlConfigSettingsSource
   from pydantic_settings import PydanticBaseSettingsSource
   ```

   **Settings class:**
   - `model_config = SettingsConfigDict(toml_file="config.toml", env_prefix="BBJ_RAG_")`
   - Fields with types and defaults:
     - `database_url: str = Field(default="postgresql://localhost:5432/bbj_rag")`
     - `embedding_model: str = Field(default="text-embedding-3-small")`
     - `embedding_dimensions: int = Field(default=1536)`
     - `chunk_size: int = Field(default=512)`
     - `chunk_overlap: int = Field(default=64)`
     - `flare_source_path: str = Field(default="")`
     - `crawl_source_urls: list[str] = Field(default_factory=list)`
   - Override `settings_customise_sources` to set priority: init_settings > env_settings > TomlConfigSettingsSource(settings_cls). This means env vars (BBJ_RAG_DATABASE_URL etc.) override TOML values, and constructor args override everything.

   **Important:** Give `database_url` a default value so the Settings class can be instantiated without a TOML file (useful in tests). The TOML file provides the "real" values for pipeline runs.

2. Create `rag-ingestion/config.toml` with all settings filled in:
   ```toml
   database_url = "postgresql://localhost:5432/bbj_rag"
   embedding_model = "text-embedding-3-small"
   embedding_dimensions = 1536
   chunk_size = 512
   chunk_overlap = 64
   flare_source_path = ""
   crawl_source_urls = []
   ```

   This file lives in rag-ingestion/ (the working directory when running the pipeline). It is the single source of truth for default configuration — no hardcoded values elsewhere.
  </action>
  <verify>
    Run `cd rag-ingestion && uv run python -c "from bbj_rag.config import Settings; s = Settings(); print(s.database_url, s.chunk_size)"` prints the default database URL and 512.
    Run `cd rag-ingestion && BBJ_RAG_DATABASE_URL=postgresql://other:5432/test uv run python -c "from bbj_rag.config import Settings; s = Settings(); print(s.database_url)"` prints the overridden URL.
  </verify>
  <done>Settings loads from config.toml with env var overrides via BBJ_RAG_ prefix. All pipeline-configurable values (DB URL, embedding model, dimensions, chunk sizes, source paths) are externalized.</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for models, config, and content hashing</name>
  <files>
    rag-ingestion/tests/test_models.py
    rag-ingestion/tests/test_config.py
  </files>
  <action>
1. Create `rag-ingestion/tests/test_models.py` with tests:

   **Document validation tests:**
   - `test_document_valid` — construct Document with all required fields, assert no error
   - `test_document_empty_content_rejected` — content="" raises ValidationError
   - `test_document_whitespace_content_rejected` — content="   " raises ValidationError
   - `test_document_empty_generations_rejected` — generations=[] raises ValidationError
   - `test_document_extra_fields_rejected` — passing unknown field raises ValidationError (extra="forbid")
   - `test_document_strips_whitespace` — content with leading/trailing spaces is stripped by str_strip_whitespace

   **Chunk validation tests:**
   - `test_chunk_from_content_computes_hash` — call Chunk.from_content(), verify content_hash == hashlib.sha256(content.strip().encode()).hexdigest()
   - `test_chunk_from_content_deterministic` — same content produces same hash
   - `test_chunk_from_content_different_content_different_hash` — different content produces different hash
   - `test_chunk_embedding_optional` — Chunk created without embedding has embedding=None
   - `test_chunk_empty_content_rejected` — Chunk.from_content with empty content raises ValidationError

   Import `pytest` and `pydantic.ValidationError`. Use `pytest.raises(ValidationError)` for rejection tests.

2. Create `rag-ingestion/tests/test_config.py` with tests:

   **Config loading tests:**
   - `test_settings_default_values` — Settings() loads with expected defaults (database_url, chunk_size=512, etc.)
   - `test_settings_env_override` — use `monkeypatch.setenv("BBJ_RAG_CHUNK_SIZE", "1024")`, verify Settings().chunk_size == 1024
   - `test_settings_env_override_database_url` — use `monkeypatch.setenv("BBJ_RAG_DATABASE_URL", "postgresql://test:5432/x")`, verify override

   Use pytest's `monkeypatch` fixture for env var tests. Use `os.chdir` or monkeypatch to ensure config.toml is found (set CWD to rag-ingestion/).

3. Remove `rag-ingestion/tests/test_placeholder.py` (the scaffold placeholder test is no longer needed now that real tests exist).

4. Run `cd rag-ingestion && uv run pytest -v` and verify all tests pass.
5. Run `cd rag-ingestion && uv run ruff check src/ tests/` and fix any lint issues.
6. Run `cd rag-ingestion && uv run mypy src/bbj_rag/` and fix any type errors. Note: mypy may need `--ignore-missing-imports` for pydantic-settings if stubs are unavailable — add to pyproject.toml mypy overrides if needed.
  </action>
  <verify>
    `cd rag-ingestion && uv run pytest -v` — all tests pass (expect ~11 tests).
    `cd rag-ingestion && uv run ruff check src/ tests/` — no lint errors.
    `cd rag-ingestion && uv run mypy src/bbj_rag/` — no type errors (or documented overrides).
    `rag-ingestion/tests/test_placeholder.py` no longer exists.
  </verify>
  <done>Unit tests prove: Document rejects empty content and empty generations, Chunk.from_content() produces deterministic SHA-256 hashes, Settings loads defaults and respects env var overrides. All linting and type checking passes.</done>
</task>

</tasks>

<verification>
1. `cd rag-ingestion && uv sync` — lockfile updated with psycopg, pgvector, pydantic, pydantic-settings
2. `cd rag-ingestion && uv run pytest -v` — all model and config tests pass
3. `cd rag-ingestion && uv run ruff check src/ tests/` — clean
4. `cd rag-ingestion && uv run mypy src/bbj_rag/` — clean (or documented overrides)
5. `cd rag-ingestion && uv run python -c "from bbj_rag.models import Document, Chunk; from bbj_rag.config import Settings"` — all imports succeed
6. Verify config.toml contains all settings with no hardcoded values in Python modules
</verification>

<success_criteria>
- Document model validates and rejects malformed data (empty content, missing generations, extra fields)
- Chunk.from_content() produces deterministic SHA-256 content hashes from normalized content
- Settings class loads from config.toml and respects BBJ_RAG_ env var overrides
- All unit tests pass, lint is clean, types check
- pyproject.toml has psycopg[binary], pgvector, pydantic, pydantic-settings as runtime dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/09-schema-data-models/09-01-SUMMARY.md`
</output>
