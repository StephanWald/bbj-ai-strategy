---
phase: 11-bbj-intelligence
plan: 02
type: tdd
wave: 2
depends_on: ["11-01"]
files_modified:
  - rag-ingestion/src/bbj_rag/intelligence/__init__.py
  - rag-ingestion/src/bbj_rag/intelligence/doc_types.py
  - rag-ingestion/src/bbj_rag/intelligence/context_headers.py
  - rag-ingestion/tests/test_doc_types.py
  - rag-ingestion/tests/test_context_headers.py
autonomous: true

must_haves:
  truths:
    - "Document type classifier assigns one of 7 types (api-reference, concept, example, migration, language-reference, best-practice, version-note) based on heading structure and content patterns"
    - "API reference docs (bbjobjects/ with Description+Syntax+Parameters headings) are classified with high confidence"
    - "Contextual header combines TOC breadcrumb + page title into an arrow-separated string stored as a separate field"
    - "Context headers for orphan topics use directory-based fallback path"
    - "Web crawl documents get context headers from URL path segments"
    - "Adding a new document type requires only adding a new rule declaration, not restructuring the classifier"
  artifacts:
    - path: "rag-ingestion/src/bbj_rag/intelligence/doc_types.py"
      provides: "DocType StrEnum, DocTypeRule dataclass, classify_doc_type()"
      contains: "class DocType(StrEnum)"
    - path: "rag-ingestion/src/bbj_rag/intelligence/context_headers.py"
      provides: "build_context_header() function"
      contains: "def build_context_header"
    - path: "rag-ingestion/src/bbj_rag/intelligence/__init__.py"
      provides: "Updated public API with DocType, classify_doc_type, build_context_header"
      contains: "classify_doc_type"
    - path: "rag-ingestion/tests/test_doc_types.py"
      provides: "Tests for document type classifier"
      min_lines: 60
    - path: "rag-ingestion/tests/test_context_headers.py"
      provides: "Tests for contextual header builder"
      min_lines: 40
  key_links:
    - from: "rag-ingestion/src/bbj_rag/intelligence/doc_types.py"
      to: "rag-ingestion/src/bbj_rag/intelligence/generations.py"
      via: "Both consumed by intelligence __init__.py as part of the same classification pipeline"
      pattern: "from bbj_rag\\.intelligence"
    - from: "rag-ingestion/src/bbj_rag/intelligence/context_headers.py"
      to: "rag-ingestion/src/bbj_rag/parsers/flare_toc.py"
      via: "Consumes TOC breadcrumb strings produced by build_toc_index()"
      pattern: "section_path"
---

<objective>
Implement the document type classifier (7 semantic categories) and contextual chunk header builder that combines TOC breadcrumbs with page titles.

Purpose: Document type classification enables type-filtered retrieval (e.g., "show me only API references"). Contextual headers provide hierarchy context in embeddings so vector search understands where a chunk sits in the documentation tree.

Output: `doc_types.py` with extensible rule-based classifier, `context_headers.py` with header builder, comprehensive tests for both, updated intelligence package API.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-bbj-intelligence/11-RESEARCH.md
@.planning/phases/11-bbj-intelligence/11-01-SUMMARY.md
@rag-ingestion/src/bbj_rag/intelligence/__init__.py
@rag-ingestion/src/bbj_rag/intelligence/generations.py
@rag-ingestion/src/bbj_rag/parsers/flare_toc.py
@rag-ingestion/src/bbj_rag/parsers/web_crawl.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement document type classifier with extensible rule registry</name>
  <files>
    rag-ingestion/src/bbj_rag/intelligence/doc_types.py
    rag-ingestion/src/bbj_rag/intelligence/__init__.py
    rag-ingestion/tests/test_doc_types.py
  </files>
  <action>
**1. Create `intelligence/doc_types.py`** with:

a) **DocType StrEnum** with 7 members using explicit string values (hyphenated names):
   - `API_REFERENCE = "api-reference"`
   - `CONCEPT = "concept"`
   - `EXAMPLE = "example"`
   - `MIGRATION = "migration"`
   - `LANGUAGE_REFERENCE = "language-reference"`
   - `BEST_PRACTICE = "best-practice"`
   - `VERSION_NOTE = "version-note"`

b) **DocTypeRule frozen dataclass** with fields:
   - `doc_type: DocType`
   - `required_headings: frozenset[str]` (headings that MUST be present)
   - `optional_headings: frozenset[str]` (headings that boost confidence)
   - `path_patterns: tuple[str, ...]` (file path regex patterns)
   - `content_patterns: tuple[str, ...]` (content regex patterns)
   - `min_score: float = 0.5` (threshold to classify)

c) **Rule registry** `_RULES: list[DocTypeRule]` ordered by specificity (most specific first):

   - **API_REFERENCE**: required `{"Description", "Syntax"}`, optional `{"Parameters", "Return Value", "Example", "Remarks"}`, paths `(r"bbjobjects/", r"bbjinterfaces/", r"bbjevents/", r"API/")`. This matches 93.7% of bbjobjects content.

   - **VERSION_NOTE**: required `frozenset()`, optional `{"Version History", "What's New", "Release Notes", "Changes"}`, paths `(r"release", r"whatsnew", r"version")`, content `(r"(?i)version\s+\d+\.\d+",)`.

   - **MIGRATION**: required `frozenset()`, optional `{"BBj-Specific Information", "Converting", "Migration", "Migrating"}`, content `(r"(?i)migrat|(?i)convert.*from|(?i)bbj-specific",)`.

   - **EXAMPLE**: required `frozenset()`, optional `{"Example", "Sample", "Tutorial"}`, path `(r"sample", r"example", r"tutorial", r"demo")`, content `(r"(?i)step\s*\d|(?i)tutorial",)`. Must have at least one code block indicator.

   - **BEST_PRACTICE**: required `frozenset()`, optional `{"Best Practice", "Recommendation", "Guidelines", "Tips"}`, content `(r"(?i)best\s*practice|(?i)recommend|(?i)guideline",)`.

   - **LANGUAGE_REFERENCE**: required `{"Syntax"}`, optional `{"Examples", "Description"}`, paths `(r"commands/", r"events/", r"sendmsg/", r"mnemonic/")`. Matches when Syntax is present but Parameters/Return Value are NOT (distinguishing from API reference).

   - **CONCEPT** (default/fallback): No required headings. Matches everything that doesn't match above.

d) **Scoring function** `_score_rule(rule: DocTypeRule, headings: list[str], path: str, content: str) -> float`:
   - Start at 0.0
   - If ALL required_headings present: +0.4. If any required missing: return 0.0 (hard fail).
   - For each optional_heading present: +0.15 (capped at 0.45)
   - If any path_pattern matches: +0.2
   - If any content_pattern matches: +0.15
   - Return total score

e) **Classifier function** `classify_doc_type(headings: list[str], content_relative_path: str, content: str) -> str`:
   - Extract heading text from the headings list (these are already extracted by the parser as `# Heading` lines -- the function should accept plain heading text strings like `["Description", "Syntax", "Parameters"]`).
   - Score each rule in order.
   - API reference has a special guard: if `"Parameters"` or `"Return Value"` in headings AND `"Syntax"` in headings, boost API_REFERENCE by 0.2 to ensure it wins over LANGUAGE_REFERENCE.
   - Return the highest-scoring rule's DocType string value if it exceeds the rule's min_score.
   - If nothing exceeds threshold, return `DocType.CONCEPT` (concept is the safe default).
   - Return `str` not `DocType` for consistency with model field typing.

**2. Update `intelligence/__init__.py`** to add exports: `DocType`, `classify_doc_type` from `doc_types`.

**3. Create `tests/test_doc_types.py`** with:

1. `test_api_reference_full_headings` -- Description+Syntax+Parameters+Return Value -> api-reference
2. `test_api_reference_minimal` -- Description+Syntax (no params) in bbjobjects path -> api-reference
3. `test_api_reference_without_syntax` -- Description only -> NOT api-reference (concept)
4. `test_language_reference_syntax_only` -- Syntax without Parameters, in commands/ path -> language-reference
5. `test_language_reference_vs_api_reference` -- Syntax+Parameters -> api-reference (not language-reference)
6. `test_migration_headings` -- "BBj-Specific Information" heading -> migration
7. `test_migration_content_pattern` -- content with "migrating from" -> migration
8. `test_version_note_headings` -- "Version History" heading -> version-note
9. `test_example_path` -- path with "sample" and code-like content -> example
10. `test_best_practice_content` -- content with "best practice" keyword -> best-practice
11. `test_concept_fallback` -- no matching signals -> concept
12. `test_doctype_enum_values` -- all 7 DocType values are hyphenated strings
13. `test_extensibility_new_rule` -- adding a DocTypeRule to the registry works (verifies data-driven design)
14. `test_classify_bbjobjects_path_boost` -- bbjobjects/ path with Description+Syntax -> high-confidence api-reference

Run: `cd /Users/beff/_workspace/bbj-ai-strategy/rag-ingestion && uv run pytest tests/test_doc_types.py -v`
  </action>
  <verify>
Run `cd /Users/beff/_workspace/bbj-ai-strategy/rag-ingestion && uv run pytest tests/test_doc_types.py -v` -- all tests pass.

Run `cd /Users/beff/_workspace/bbj-ai-strategy/rag-ingestion && uv run python -c "from bbj_rag.intelligence import DocType, classify_doc_type; print(classify_doc_type(['Description', 'Syntax', 'Parameters'], 'bbjobjects/Window/bbjwindow.htm', ''))"` -- prints `api-reference`.

Run `cd /Users/beff/_workspace/bbj-ai-strategy/rag-ingestion && uv run ruff check src/bbj_rag/intelligence/doc_types.py` -- clean.
  </verify>
  <done>
DocType StrEnum with 7 types, extensible DocTypeRule registry with scoring function, classify_doc_type() correctly classifying API references (93.7% of bbjobjects), language references, migrations, version notes, examples, best practices, and falling back to concept. 14+ tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement contextual header builder and final integration tests</name>
  <files>
    rag-ingestion/src/bbj_rag/intelligence/context_headers.py
    rag-ingestion/src/bbj_rag/intelligence/__init__.py
    rag-ingestion/tests/test_context_headers.py
  </files>
  <action>
**1. Create `intelligence/context_headers.py`** with:

a) **build_context_header function:**
```
def build_context_header(
    section_path: str,
    title: str,
    heading_path: str = "",
) -> str:
```
   - Combines section_path (TOC breadcrumb or directory fallback), title, and optional heading_path into an arrow-separated string.
   - Deduplication: If title already appears at the END of section_path, don't repeat it. Check with `section_path.endswith(title)` after stripping.
   - If section_path is empty, just use title (+ heading_path if present).
   - If all inputs empty, return empty string.
   - Separator: ` > ` (arrow with spaces).
   - heading_path is for future use during chunking (Phase 12) -- it will carry within-page heading context like "Parameters" or "Remarks". For now, callers pass empty string or the relevant section heading.

b) **extract_heading_hierarchy function:**
```
def extract_heading_hierarchy(content: str) -> list[str]:
```
   - Takes markdown content (as produced by parsers) and extracts heading text.
   - Parses lines starting with `# `, `## `, `### `, etc.
   - Returns flat list of heading text strings (e.g., `["Description", "Syntax", "Parameters", "Return Value"]`).
   - This is used by classify_doc_type (which needs heading list) and will be used by the future chunker.
   - Strips the `# ` prefix and any trailing whitespace.

c) **url_path_to_hierarchy function:**
```
def url_path_to_hierarchy(url: str, base_url: str) -> str:
```
   - Wraps the existing `web_crawl.url_to_hierarchy` logic for web crawl documents.
   - Takes a full URL and base URL, returns arrow-separated section path.
   - This provides a single entry point in the intelligence package for both Flare and web crawl hierarchy paths.
   - Implementation: import and delegate to `web_crawl.url_to_hierarchy`.

**2. Update `intelligence/__init__.py`** to export: `build_context_header`, `extract_heading_hierarchy` from `context_headers`.

**3. Create `tests/test_context_headers.py`** with:

1. `test_build_header_full` -- section_path + title + heading_path -> "A > B > C > D"
2. `test_build_header_no_heading_path` -- section_path + title -> "A > B > C"
3. `test_build_header_title_dedup` -- section_path ending with title -> title not repeated
4. `test_build_header_no_section_path` -- empty section_path + title -> just "Title"
5. `test_build_header_all_empty` -- all empty -> empty string
6. `test_build_header_web_crawl_style` -- URL-derived section path + title -> arrow-separated
7. `test_extract_heading_hierarchy_basic` -- markdown with `## Description\n## Syntax\n## Parameters` -> `["Description", "Syntax", "Parameters"]`
8. `test_extract_heading_hierarchy_mixed_levels` -- `# Title\n## Section\n### Subsection` -> `["Title", "Section", "Subsection"]`
9. `test_extract_heading_hierarchy_no_headings` -- plain text -> empty list
10. `test_extract_heading_hierarchy_strips_whitespace` -- headings with trailing spaces -> cleaned
11. `test_url_path_to_hierarchy` -- full URL -> arrow-separated path (delegates to web_crawl)
12. `test_url_path_to_hierarchy_root` -- base URL itself -> empty string

Run: `cd /Users/beff/_workspace/bbj-ai-strategy/rag-ingestion && uv run pytest tests/test_context_headers.py -v`

Run full suite: `cd /Users/beff/_workspace/bbj-ai-strategy/rag-ingestion && uv run pytest tests/ -v`
  </action>
  <verify>
Run `cd /Users/beff/_workspace/bbj-ai-strategy/rag-ingestion && uv run pytest tests/test_context_headers.py -v` -- all tests pass.

Run `cd /Users/beff/_workspace/bbj-ai-strategy/rag-ingestion && uv run pytest tests/ -v` -- full suite passes (no regressions).

Run `cd /Users/beff/_workspace/bbj-ai-strategy/rag-ingestion && uv run python -c "from bbj_rag.intelligence import build_context_header, extract_heading_hierarchy; h = extract_heading_hierarchy('## Description\n\nSome text\n\n## Syntax\n\nCode here'); print(h); print(build_context_header('Language > BBjAPI > BBjWindow', 'addButton', ''))"` -- prints `['Description', 'Syntax']` and `Language > BBjAPI > BBjWindow > addButton`.

Run `cd /Users/beff/_workspace/bbj-ai-strategy/rag-ingestion && uv run ruff check src/bbj_rag/intelligence/` -- clean.
  </verify>
  <done>
Contextual header builder combining TOC breadcrumbs + title with deduplication, heading hierarchy extractor from markdown content, URL-path hierarchy adapter for web crawl. 12+ tests pass. Full intelligence package complete: Generation tagger + DocType classifier + Context headers + Report.
  </done>
</task>

</tasks>

<verification>
1. `uv run python -c "from bbj_rag.intelligence import DocType; print(list(DocType))"` prints all 7 types
2. `uv run python -c "from bbj_rag.intelligence import classify_doc_type; print(classify_doc_type(['Description', 'Syntax', 'Parameters'], 'bbjobjects/foo.htm', ''))"` prints `api-reference`
3. `uv run python -c "from bbj_rag.intelligence import build_context_header; print(build_context_header('A > B', 'C'))"` prints `A > B > C`
4. `uv run pytest tests/test_doc_types.py tests/test_context_headers.py -v` -- all tests pass
5. `uv run pytest tests/ -v` -- full suite passes
6. `uv run ruff check src/bbj_rag/intelligence/` -- clean
7. classify_doc_type returns "concept" for unrecognized content (safe default)
8. build_context_header deduplicates title when it already appears at end of section_path
</verification>

<success_criteria>
- DocType StrEnum has exactly 7 members with hyphenated string values
- classify_doc_type() takes (headings, path, content) and returns a type string
- Rule registry is data-driven -- adding a new type means adding a new DocTypeRule, not a new if/elif branch
- API reference classification is high-confidence for Description+Syntax+Parameters pattern
- build_context_header() combines section_path + title + heading_path with deduplication
- extract_heading_hierarchy() parses markdown headings into a flat list
- All new tests pass, no regressions in existing tests
- Intelligence __init__.py exports all public API: Generation, tag_generation, DocType, classify_doc_type, build_context_header, extract_heading_hierarchy, print_report
</success_criteria>

<output>
After completion, create `.planning/phases/11-bbj-intelligence/11-02-SUMMARY.md`
</output>
